<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Somersames</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://somersames.github.io/"/>
  <updated>2021-07-26T14:57:41.260Z</updated>
  <id>https://somersames.github.io/</id>
  
  <author>
    <name>Somersames</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线程池是如何关闭非核心线程的</title>
    <link href="https://somersames.github.io/2021/07/21/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%98%AF%E5%A6%82%E4%BD%95%E5%85%B3%E9%97%AD%E9%9D%9E%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E7%9A%84/"/>
    <id>https://somersames.github.io/2021/07/21/线程池是如何关闭非核心线程的/</id>
    <published>2021-07-20T16:21:28.000Z</published>
    <updated>2021-07-26T14:57:41.260Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java 中，多线程的核心实现类是 ThreadPoolExecutor，该类提供了多线程的几个参数，用于开发人员自定义自己的线程池。</p><h1 id="线程池的参数"><a href="#线程池的参数" class="headerlink" title="线程池的参数"></a>线程池的参数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>线程池一共有 7 个参数，其中跟本次相关的有三个，分别是 corePoolSize、maximumPoolSize、keepAliveTime，这三个参数代表的意思如下：</p><ul><li>corePoolSize：当线程池中的任务数小于 corePoolSize 或者线程池中的任务数大于 corePoolSize 但是小于阻塞队列的最大长度，那么线程池中的核心线程数就睡 &lt;= corePoolSize</li><li>maximumPoolSize：当线程池中的任务数已经达到队列上限并且线程池中的线程数 &lt; maximumPoolSize，此时线程池就会将线程数增加至 maximumPoolSize</li><li>keepAliveTime：代表线程的空闲时间，也就是线程等待多久以后可以被销毁</li></ul><p>如果一个线程池中，线程数已经达到了 maximumPoolSize，如果后续任务数减少，此时就会销毁多余的线程，具体保留多少线程数还是需要依据线程池的具体参数，<br>例如如果配置了 allowCoreThreadTimeOut，则所有线程都有被回收的可能。</p><h1 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h1><p>线程池一共有五种状态，按照源代码中的定义分别如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;-<span class="number">536870912</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;<span class="number">0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;<span class="number">536870912</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;<span class="number">1073741824</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;<span class="number">1610612736</span></span><br></pre></td></tr></table></figure></p><p>其中状态的变化如下图：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%98%AF%E5%A6%82%E4%BD%95%E5%85%B3%E9%97%AD%E9%9D%9E%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E7%9A%84/threadPoolStatus.png" alt=""></p><ul><li>RUNNING 表示该线程池一切正常，可以接受新的任务并且队列中的任务也会执行</li><li>SHUTDOWN 表示该线程池拒绝接受新的任务，处于队列中的任务也会执行完毕</li><li>STOP 表示该线程池拒绝接受新的任务，而且队列中的任务不会执行，并且会向正在执行中的任务发送一个中断指令</li><li>TIDYING 表示所有线程已经被终止，而且工作线程已经为 0，线程池即将去执行 terminated 钩子函数</li><li>TERMINATED terminated() 函数已经执行完毕，线程池被销毁</li></ul><p>上面铺垫这么多了，现在可以回到主题了</p><h1 id="线程池是如何关闭非核心线程的"><a href="#线程池是如何关闭非核心线程的" class="headerlink" title="线程池是如何关闭非核心线程的"></a>线程池是如何关闭非核心线程的</h1><p>首先，还记得第一个标题里面的 keepAliveTime、workQueue 吗，线程池中的线程如果需要被销毁，满足下面任意一个条件即可：</p><ol><li>线程中的业务代码执行出现了异常</li><li>线程池中的线程在等待了 keepAliveTime 后还是拿不到任务</li></ol><p>下面从线程开始获取任务的地方开始：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">                decrementWorkerCount();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">            <span class="comment">// 如果允许核心线程被销毁或者此时总线程数  &gt; core，可以进行线程的销毁</span></span><br><span class="line">            <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">                &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 当 timed 为 true，那么会等待 timeout 时间，如果为 false，则直接阻塞，除非拿到任务</span></span><br><span class="line">                Runnable r = timed ?</span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                    workQueue.take();</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                timedOut = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">                timedOut = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在 getTask 方法中，第一步会判断线程池的状态，如果是处于 SHUTDOWN &amp;&amp; 队列为空，或者是处于 STOP 状态，则可以直接减少当前的工作数量了，因为线程池的状态流转到 TIDYING 的条件是：线程数为 0 且队列为空，而此时队列已经是空了，所以只需要减少当前的工作线程数就可以完成状态的流转。</p><p>如果此时的线程池状态为 RUNNING，那么会进行两个判断：</p><ol><li>是否允许 core 线程销毁或</li><li>当前的线程数是否大于 corePoolSize</li></ol><p>这两个判断就决定当前线程是否会被销毁，线程池中的线程通过 <code>poll(long timeout, TimeUnit unit)</code> 这个函数来获取任务，在等待 timeout 时间以后，就会将 timedOut 设置为 true，表示已经等待了 keepAliveTime 时间了，但是还没有拿到任务。</p><p>此时 <code>(wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())</code> 这个判断就很容易通过了，于是会通过 CAS 操作原子性的减少工作线程数，一旦设置成功，则会直接返回 null，然后就会进行线程的销毁。</p><h2 id="processWorkerExit"><a href="#processWorkerExit" class="headerlink" title="processWorkerExit"></a>processWorkerExit</h2><p>当拿不到任务的时候，就会执行 processWorkerExit，如果线程执行的过程中出现了异常也是从这个方法进入并进行销毁的，不过线程执行出错的情况下 completedAbruptly 是 true。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>processWorkerExit 主要是做了以下几个操作： </p><ol><li>上报该 worker 已经执行完毕的任务数，并且从 workers 集合中移除该 worker。</li><li>执行 tryTerminate()</li><li>判断是否是异常导致的线程销毁，如果是的则补充一个 worker，如果不是的，则判断当前 worker 数量是否大于线程池允许的最小数，如果小于的话也会补充 worker。</li></ol><p>其中最关键是这里面的第2步 tryTerminate 方法</p><h2 id="tryTerminate"><a href="#tryTerminate" class="headerlink" title="tryTerminate"></a>tryTerminate</h2><p>tryTerminate 会判断当前线程池的状态，如果符合一定的条件，那么就会让线程池向 TERMINATED 进行转换。</p><p>如果此时的线程池满足以下任意一个条件，则不会做任何的操作，直接返回：</p><ol><li>线程池处于 RUNNING、TIDYING、TERMINATED。</li><li>正在处于 SHUTDOWN，但是队列中还有等待执行的任务。</li></ol><p>当一个线程池不满足以上的情况的时候，那么剩下的就是：</p><ol><li>处于 STOP</li><li>处于 SHUTDOWN，但是队列已空</li></ol><p>从上面得知，STOP 状态下是队列中的任务是不会进行处理的，所以此时将线程池状态由 STOP 向 TERMINATED 是合理的。而如果处于 SHUTDOWN 且队列为空，此时也是可以向 TERMINATED 转移的。而且在转移的过程中，如果判断此时线程池中的 worker 数量大于 0，那么会直接随机中断一个线程，然后返回，保留线程池的当前状态。</p><p>这里之所以尝试中断一个线程，是因为假设线程池在执行了 shutdown 之后，如果队列中还有任务，此时并不会向 TERMINATED 转换，但是此时由于 shutdown 中的中断方法已经执行了，所以后续就需要再次中断 worker，而这里加一个判断，就是处理这种情况。</p><p>而如果上述的判断都是 false，此时证明已经可以转为 TERMINATED 了。转换的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">mainLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            terminated();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">            termination.signalAll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mainLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改线程状态为 TIDYING，然后执行 terminated() 函数，最后再唤醒所有的 termination()</p><h2 id="termination"><a href="#termination" class="headerlink" title="termination"></a>termination</h2><p>termination 这个变量是一个 condition，在 ThreadPoolExecutor 中只有两个地方出现过，一个是在 awaitTermination 中，另一个就是在 termination，不过在 awaitTermination 是等待获取线程池的状态：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runStateAtLeast(ctl.get(), TERMINATED))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = termination.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而线程池已经到了 TERMINATED，自然可以唤醒 termination了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Java 中，多线程的核心实现类是 ThreadPoolExecutor，该类提供了多线程的几个参数，用于开发人员自定义自己的线程池。&lt;/p&gt;
&lt;h1 id=&quot;线程池的参数&quot;&gt;&lt;a href=&quot;#线程池的参数&quot; class=&quot;headerlink&quot; title=&quot;线程池
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redis中ziplist的实现二</title>
    <link href="https://somersames.github.io/2021/07/18/Redis%E4%B8%ADziplist%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BA%8C/"/>
    <id>https://somersames.github.io/2021/07/18/Redis中ziplist的实现二/</id>
    <published>2021-07-18T05:55:58.000Z</published>
    <updated>2021-07-18T17:14:46.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="添加-entry"><a href="#添加-entry" class="headerlink" title="添加 entry"></a>添加 entry</h1><p>ziplist 的添加过程大致如下：</p><ul><li><p>如果是一个新建的 ziplist，其中新增元素的时候，直接将 prevlen 设置为 0 即可</p></li><li><p>如果是在中间位置新增，那么首先需要获取前一个 entry 的长度，因为后面的元素已经计算过了，因此直接拿来用即可</p></li><li><p>如果是在尾部进行新增元素，那么需要计算其前一个元素的长度，因为 zlend 不会保存前一个最后一个尾节点的长度，因此需要在新增的时候计算</p></li></ul><h1 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h1><p>由于 ziplist 的设计，当前一个元素长度小于 254 的时候， prevlen 会以一个字节进行存储，但是当前一个元素大于 254 的时候，那么 prevlen 就会变成 5 个字节<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_DECODE_PREVLENSIZE(ptr, prevlensize) do &#123;</span></span><br><span class="line">    <span class="keyword">if</span> ((ptr)[<span class="number">0</span>] &lt; ZIP_BIG_PREVLEN) &#123;                                          </span><br><span class="line">        (prevlensize) = <span class="number">1</span>;                                                     </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                                                   </span><br><span class="line">        (prevlensize) = <span class="number">5</span>;                                                    </span><br><span class="line">    &#125;                                                                          </span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>其中前一个字节固定为 FE，后面四个字节存储的是前一个 entry 的长度，这个也很好理解，</p><h2 id="为什么是-254"><a href="#为什么是-254" class="headerlink" title="为什么是 254"></a>为什么是 254</h2><p>因为 ziplist 也需要像其他的双向链表一样，需要有一个 head 和 tail 来表示头尾，head 节点因为前面没有 entry，所以 prevlen 是 0，而尾节点 redis 作者就将其设置为 255，当遍历的时候，如果遇到 prevlen 的值是 255 的就表示该节点是一个尾节点。<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/Redis%E4%B8%ADziplist%E7%9A%84%E5%AE%9E%E7%8E%B0/why255.png" width="500" height="256" style="margin: 0 auto;"></p><p>所以在 redis 的源码中也经常看到 <code>ptr[0] == 255</code> 这种判断来判断是否是尾节点</p><h2 id="连锁更新触发的场景"><a href="#连锁更新触发的场景" class="headerlink" title="连锁更新触发的场景"></a>连锁更新触发的场景</h2><p>因为 redis 的 prevlen 存在两种存储方式，如果前一个节点的长度发生变化，那么不可避免的需要更新后续的 entry<br>例如原有的 ziplist 的 entry 如下：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/Redis%E4%B8%ADziplist%E7%9A%84%E5%AE%9E%E7%8E%B0/entry1.png" width="500" height="256" style="margin: 0 auto;"></p><p>现在需要在 entry1 和 entry2 之间新增一个 entry，如果新增的 entry 长度大于 254，那么 entry2 的 prevlen 势必会需要扩容<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/Redis%E4%B8%ADziplist%E7%9A%84%E5%AE%9E%E7%8E%B0/add_entry.png" width="500" height="256" style="margin: 0 auto;"></p><p>此时由于新增的 entry 长度已经大于 254，所以 entry2 的 prevlen 需要由 1个字节扩展到 5个字节，而且还会进行递归进行下去，一直到后一个节点的 prevlen 不需要更新为止</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>在 redis 中，list、zset、hash 在数据量小的时候都会使用 ziplist 作为其存储数据的结构，而且三种结构都支持自定义的配置：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Zip structure config, see redis.conf for more information  */</span></span><br><span class="line">   <span class="keyword">size_t</span> hash_max_ziplist_entries;</span><br><span class="line">   <span class="keyword">size_t</span> hash_max_ziplist_value;</span><br><span class="line">   <span class="keyword">size_t</span> zset_max_ziplist_entries;</span><br><span class="line">   <span class="keyword">size_t</span> zset_max_ziplist_value;</span><br><span class="line">   <span class="comment">/* List parameters */</span></span><br><span class="line">   <span class="keyword">int</span> list_max_ziplist_size;</span><br></pre></td></tr></table></figure></p><p>其中 list 的配置少了一个 <code>_value</code>，是因为 list 这种数据后续无论怎样存储都会是一个双向链表，不用考虑每一次 value 的大小，但是最后如果元素 &gt; <code>list_max_ziplist_size</code>，则会变成 quicklist</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;添加-entry&quot;&gt;&lt;a href=&quot;#添加-entry&quot; class=&quot;headerlink&quot; title=&quot;添加 entry&quot;&gt;&lt;/a&gt;添加 entry&lt;/h1&gt;&lt;p&gt;ziplist 的添加过程大致如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果是一个新建的 zi
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redis中ziplist的实现(一)</title>
    <link href="https://somersames.github.io/2021/07/12/Redis%E4%B8%ADziplist%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%80/"/>
    <id>https://somersames.github.io/2021/07/12/Redis中ziplist的实现一/</id>
    <published>2021-07-11T16:08:55.000Z</published>
    <updated>2021-07-18T17:15:04.796Z</updated>
    
    <content type="html"><![CDATA[<p>ziplist 是一个双向链表，但是不同于熟知的利用头指针和尾指针所形成的双向链表，ziplist 而是采用了一个特殊的实现</p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>普通的双向链表因为在每一个节点上都含有一个头节点和尾节点，所以在遍历的时候可以依次沿着每一个节点进行递归，而且在新增或者删除的时候，直接移动指针即可，并且每一个节点在内存中并不要求是连续的，只需要指针指向对应节点的内存地址即可。</p><p>但是 redis 使用的是内存，在内存满了的情况下就会造成 redis 的不可用，需要依据淘汰策略清理内存。</p><p>试想下如果 ziplist 像普通的双向链表一样，每一次新增一个 entry 都去申请一块新的内存，实现起来确实比较简单。</p><p>但是由于每一次的 value 大小都是不一样的，每一次都去申请一块新的内存，很容易造成很多的内存碎片。<br>现象之一就是，如果后续需要新增一个 value，却发现内存中还有很多内存碎片，但是大小都比当前 value 小，造成了 redis 不得不提前进行淘汰</p><p>所以 redis 作者在 Hash、zset、set 这三种结构中加入了一个额外的逻辑，如果数据量小则会使用 ziplist 作为其数据的存储结构</p><h1 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h1><p>ziplist 会在初始化的时候直接分配一整块内存，默认初始化的大小为 <code>ZIPLIST_HEADER_SIZE+ZIPLIST_END_SIZE</code>，而这两个值的大小分别是 (4 * 2 + 2) + 1 = 11字节</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>在 ziplist.c 文件的顶部注释中，其结构如下：</p><blockquote><p> <code>&lt;zlbytes&gt; &lt;zltail&gt; &lt;zllen&gt; &lt;entry&gt; &lt;entry&gt; ... &lt;entry&gt; &lt;zlend&gt;</code></p></blockquote><ul><li><p>zlbytes<br>用来计算整个 ziplist 大小，主要用于 resize，大小为 4bytes</p></li><li><p>zltail<br>这个表示 ziplist 从第一个字节到最后一个 entry 的偏移量，主要用于在尾部新增元素使用</p></li><li><p>zllen<br>表示整个 ziplist 中 entry 的数量，最大值为 2^16-1，</p></li><li><p>zlend<br>作为一个特殊的尾节点，大小为1个 byte，这个节点存在的意义就是方便进行尾插</p></li></ul><p>其中 zltail 可以理解普通链表的尾节点，</p><h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p>entry 的结构如下：<code>&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</code><br>其中 prevlen 表示上一个节点的长度，方便进行链表从尾部向头部进行遍历，在遍历的过程中，只需要移动 prevlen 就可以得到前一个 entry 地址<br>而 encoding 则代表该 content 的类型以及长度，按照 redis 源码的注释，整理如下：</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>如果存储内容是 String，那么 encoding 的值会随着 string 的长度改变而改变<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/Redis%E4%B8%ADziplist%E7%9A%84%E5%AE%9E%E7%8E%B0/string.png" width="500" height="256" style="margin: 0 auto;"></p><p>例如：如果要存储的字符串是长度为 30 的全英文字符串（或者字节长度为30的中文）<br>那么这个 entry 所的结构就如下图所示<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/Redis%E4%B8%ADziplist%E7%9A%84%E5%AE%9E%E7%8E%B0/clipboard_20210715_011629.png" width="500" height="256" style="margin: 0 auto;"></p><p>其中 prevlen 代表上一个 entry 的长度，当从尾部进行遍历，可以直接偏移 prevlen 个长度然后直接得出上一个 entry 的内存地址。<br>由于存储的字符串长度小于 63，则采用「00pppppp」的方式存储字符串长度，而 30 个长度对应的 16 进制正好是 1e，所以这个字节就存储的是 1e，而后续的 data 存储的就是真正的原始内容了</p><blockquote><p>tips:一个字节=2个16进制数，=8个2进制数</p></blockquote><h3 id="int"><a href="#int" class="headerlink" title="int"></a>int</h3><p>如果存储的内容是 int 类型，那么 ziplist 的 encoding 则会通过另一种方式进行存储<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/Redis%E4%B8%ADziplist%E7%9A%84%E5%AE%9E%E7%8E%B0/int.png" width="500" height="256" style="margin: 0 auto;"><br>其中 encoding 有 5 中类型，分别对应的是 int 的几个大小</p><p>这里还有一个小细节：<br>因为 ff(11111111) 这种 encoding 表示的是尾节点，但是在 f0(11110000) 至 fe(11111110) 之间还有 4 个 bit 没有被使用，分别是 0001 至 1101，也就是 1 到 13，于是 redis 的作者就想，能不能把这部分的空间利用起来呢？</p><p>所以如果 int 的值处于 1-13 之间，那么此时直接和 encoding 存储在一起，避免额外开辟一个字节的空间来存储数据，减少内存的使用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ziplist 是一个双向链表，但是不同于熟知的利用头指针和尾指针所形成的双向链表，ziplist 而是采用了一个特殊的实现&lt;/p&gt;
&lt;h1 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class=&quot;headerlink&quot; title=&quot;区别&quot;&gt;&lt;/a&gt;区别&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redis中String的实现细节</title>
    <link href="https://somersames.github.io/2021/07/01/Redis%E4%B8%ADString%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/"/>
    <id>https://somersames.github.io/2021/07/01/Redis中String的实现细节/</id>
    <published>2021-06-30T17:13:22.000Z</published>
    <updated>2021-07-11T15:55:54.170Z</updated>
    
    <content type="html"><![CDATA[<p>String 是 Redis 中的基本数据结构之一，也是日常开发中使用最多的场景，例如秒杀扣库存，token缓存，详情缓存等，使用的频率还是比较高的，但是 Redis 中的 String 实现还是比较复杂的。</p><p>String 最底层的数据结构还是 char[]，但是 Redis 在对数组进行封装的时候，做了一些细节上的优化</p><h1 id="Redis-对象"><a href="#Redis-对象" class="headerlink" title="Redis 对象"></a>Redis 对象</h1><p>在 Redis 中，每一个 Key 都可以称之为一个对象，Redis 包含了这个 Key 的类型，value 的内存地址，LRU 淘汰时间，引用计数等<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RedisObject</span> &#123;</span></span><br><span class="line">    int4 type;</span><br><span class="line">    <span class="keyword">int</span> <span class="number">4</span> encoding;</span><br><span class="line">    int24 lru;</span><br><span class="line">    int32 refcount;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>type 表示这个对象的类型：String、list、set、zset、hash、stream、module</li><li><p>encoding 表示该 Key 的 value 以什么类型存储，在 Redis 中有如下几个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* No longer used: old list encoding. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_STREAM 10 <span class="comment">/* Encoded as a radix tree of listpacks */</span></span></span><br></pre></td></tr></table></figure></li><li><p>lru 代表的是该 Key 被最后一次访问的时间</p></li><li>refcount 表示的被引用的次数，当refcount 为 0 的时候，对象就会被回收</li><li>*prt 代表的是内存指针，指向真正存储该 value 的内存区域</li></ul><h1 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h1><p>SDS 是 Redis 中字符串的具体实现，其结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SDS</span> &#123;</span></span><br><span class="line">    int8 len;</span><br><span class="line">    int8 alloc;</span><br><span class="line">    int8 flags;</span><br><span class="line">    byte[] buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>len 表示的当前所使用的长度</li><li>alloc 表示的是分配的内存大小（去除了 sdshrd 以及末尾的结束字符）</li><li>flags 则是一个 8bits 的变量，前三位表示类型，后 5 位暂时还没使用</li><li>buf 是字符串具体存放的地址</li></ul><h2 id="flags-的几种含义"><a href="#flags-的几种含义" class="headerlink" title="flags 的几种含义"></a>flags 的几种含义</h2><p>Redis 中的 String 有几种 sdshdr，分别是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5  0  最大长度：1&lt;&lt;5 = 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_8  1  最大长度：1&lt;&lt;8 = 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_16 2  最大长度：1&lt;&lt;16 = 65535</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_32 3  最大长度：1&lt;&lt;32 = 2^32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_64 4  最大长度：1&lt;&lt;64 = 2^64</span></span><br></pre></td></tr></table></figure></p><p>在这里面，SDS_TYPE_5 基本不会使用，因为只能存放 32 个字符串，有一种特情况是，如果设置的字符串长度为0，会直接使用 SDS_TYPE_8，而不是 SDS_TYPE_5</p><h1 id="字符串的存储方式"><a href="#字符串的存储方式" class="headerlink" title="字符串的存储方式"></a>字符串的存储方式</h1><p>假设现在分别有两个字符串需要存储，分别是 a 和 aaa…aaa（100）个，常见的做法是直接为这两个字符和都开辟一块内存。</p><p>但是 Redis 使用的是内存进行存储的，可以存储多少数据完全取决于内存容量的大小，在内存不变的情况下，能存储多少数据取决的每一个 value 的大小，所以 Redis 的作者对 String 的存储进行了优化。</p><p>前面提到过 Redis 的对象有一共有五个字段，其分别如下<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/Redis%E4%B8%AD%E7%9A%84String/clipboard_20210704_010238.png" width="500" height="256" style="margin: 0 auto;"></p><p>在 64位操作系统的机器上，Redis 对象的大小是 64 bits，那么剩下的 48bits 是否就可以利用起来存储 String 呢？</p><p>于是 embstr 这种存储方式就出现了</p><h2 id="embstr"><a href="#embstr" class="headerlink" title="embstr"></a>embstr</h2><p>上面提到 Redis对象剩下的可存储容量是 48bits，那么可以真正用来存储字符串的有多少呢？ </p><h2 id="阈值计算"><a href="#阈值计算" class="headerlink" title="阈值计算"></a>阈值计算</h2><p>首先 RedisObject 自己就需要占用 16 个字节，所以剩下可以给 SDS 用的也就是 64 - 16 = 48 字节</p><p>前面提到了 SDS 的结构，首先 sdshdr 就需要占用 3 个字节，而且 sds 字符串结尾需要以 NULL 结尾，所以由占用了一个字节，那么最终的阈值就是 44<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/Redis%E4%B8%AD%E7%9A%84String/clipboard_20210702_010522.png?" width="500" height="256" style="margin: 0 auto;"></p><p>也就是当设置的字符串长度小于等于 44 的时候，Redis 将会直接将 SDS 拼接到 ptr 之后，避免新开辟一块内存区域</p><h2 id="Redis-测试"><a href="#Redis-测试" class="headerlink" title="Redis 测试"></a>Redis 测试</h2><p>在这里设置了一个Key a，它的长度刚好是 44，于是对 a 进行debug<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set a '12345678901234567890123456789012345678901234'</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; debug object a</span><br><span class="line">Value at:0x7f82e06150c0 refcount:1 encoding:embstr serializedlength:21 lru:14548208 lru_seconds_idle:3</span><br></pre></td></tr></table></figure></p><p>可以看到 a 的编码方式刚好是 emdstr，那么再增加一个字符呢？<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set b '123456789012345678901234567890123456789012345'</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; debug object b</span><br><span class="line">Value at:0x7f82e0666640 refcount:1 encoding:raw serializedlength:21 lru:14548247 lru_seconds_idle:2</span><br></pre></td></tr></table></figure></p><p>可以看到 b 的编码方式已经变成 RAW 了。</p><h1 id="RAW-编码"><a href="#RAW-编码" class="headerlink" title="RAW 编码"></a>RAW 编码</h1><p>当字符串长度大于 44 以后，就会将编码方式改为 RAW，Redis 会新开辟一块内存区域来存储 SDS，并且将 ptr 指针指向该内存区域</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(*o));</span><br><span class="line">    o-&gt;type = type;</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_RAW;</span><br><span class="line">    <span class="comment">// *ptr 是 SDS 的内存指针，然后将 Redis 的 ptr 指向 SDS</span></span><br><span class="line">    o-&gt;ptr = ptr;</span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the LRU to the current lruclock (minutes resolution), or</span></span><br><span class="line"><span class="comment">     * alternatively the LFU counter. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">        o-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | LFU_INIT_VAL;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        o-&gt;lru = LRU_CLOCK();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用 Redis 的时候，常用的还有 <code>incr</code> 和 <code>incrBy</code>，那么 Redis 又会以怎样的方式存储呢？</p><h1 id="int"><a href="#int" class="headerlink" title="int"></a>int</h1><p>当通过 set 命令设置的 value 可以被转换为 long  类型的时候，Redis 就会尝试将其作为 int 的方式进行存储，int 方式存储本质上也是将其和 ReidsObject 放在一起</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set a 123</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding a</span><br><span class="line">"int"</span><br></pre></td></tr></table></figure><h2 id="Redis-是如何进行判断的？"><a href="#Redis-是如何进行判断的？" class="headerlink" title="Redis 是如何进行判断的？"></a>Redis 是如何进行判断的？</h2><p>在 src/object.c 文件中，tryObjectEncoding 方法详细的做了详细的判断，在这里有一个小细节就是 Redis 采用了一个对象池来复用 1 到 10000 之间的数字，复用的条件限制如下：</p><ul><li>Redis 没有设置最大内存限制</li><li>Redis 的设置了淘汰算法，但是淘汰算法不是 LRU 或者 LFU</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Try to encode a string object in order to save space */</span></span><br><span class="line"><span class="function">robj *<span class="title">tryObjectEncoding</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> value;</span><br><span class="line">    sds s = o-&gt;ptr;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断言必须是 String</span></span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,o,o-&gt;type == OBJ_STRING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其目前的 encoding 方式必须是 RAW 或者是 embStr</span></span><br><span class="line">    <span class="keyword">if</span> (!sdsEncodedObject(o)) <span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享变量不参与encoding</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount &gt; <span class="number">1</span>) <span class="keyword">return</span> o;</span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    <span class="comment">// 如果长度大于 20 并且 可以转化为long类型</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">20</span> &amp;&amp; string2l(s,len,&amp;value)) &#123;</span><br><span class="line">        <span class="comment">/* 如果没有内存限制或者 没有 将 Key 的淘汰策略设置为 LRU or LFU</span></span><br><span class="line"><span class="comment">           并且 value &gt;=0 切 小于 10000，则使用共享策略</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> ((server.maxmemory == <span class="number">0</span> ||</span><br><span class="line">            !(server.maxmemory_policy &amp; MAXMEMORY_FLAG_NO_SHARED_INTEGERS)) &amp;&amp;</span><br><span class="line">            value &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            value &lt; OBJ_SHARED_INTEGERS)</span><br><span class="line">        &#123;</span><br><span class="line">            decrRefCount(o);</span><br><span class="line">            incrRefCount(shared.integers[value]);</span><br><span class="line">            <span class="keyword">return</span> shared.integers[value];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不满足上面的 if 条件，且原编码是 raw， 则还是设置为 int</span></span><br><span class="line">            <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_RAW) &#123;</span><br><span class="line">                sdsfree(o-&gt;ptr);</span><br><span class="line">                o-&gt;encoding = OBJ_ENCODING_INT;</span><br><span class="line">                o-&gt;ptr = (<span class="keyword">void</span>*) value;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_EMBSTR) &#123;</span><br><span class="line">                <span class="comment">// 如果是 embStr，则</span></span><br><span class="line">                decrRefCount(o);</span><br><span class="line">                <span class="keyword">return</span> createStringObjectFromLongLongForValue(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;String 是 Redis 中的基本数据结构之一，也是日常开发中使用最多的场景，例如秒杀扣库存，token缓存，详情缓存等，使用的频率还是比较高的，但是 Redis 中的 String 实现还是比较复杂的。&lt;/p&gt;
&lt;p&gt;String 最底层的数据结构还是 char[]，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅谈 synchronized 和 volatile</title>
    <link href="https://somersames.github.io/2021/05/30/difference-between-synchronized-and-volatile/"/>
    <id>https://somersames.github.io/2021/05/30/difference-between-synchronized-and-volatile/</id>
    <published>2021-05-29T16:30:34.000Z</published>
    <updated>2021-06-12T17:06:27.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、锁"><a href="#一、锁" class="headerlink" title="一、锁"></a>一、锁</h1><p>从细节上来说，锁分为 乐观锁、悲观锁</p><p>乐观锁适用于读多写少的场景，一般是通过 CAS 进行操作，因为不用加锁，所以性能上比悲观锁优秀太多</p><p>悲观锁适用于写多读少的场景，性能开销比较大。</p><h2 id="1：乐观锁"><a href="#1：乐观锁" class="headerlink" title="1：乐观锁"></a>1：乐观锁</h2><p>在 Java 中的 <code>Unsafe</code> 的 <code>compareAndSwapInt</code> 就是用到了这个特性</p><p>但是乐观锁还会产生一个 <code>ABA</code> 的问题，一般是通过 <code>version版本号</code> 的方式来解决<br>另外一个就是竞争问题，如果大量的线程都在进行 CAS 操作，那么势必会造成某些线程 CAS 操作非常耗时，会白白的浪费非常多的 CPU 资源，甚至造成 CPU 100% 的情况</p><h2 id="2：自旋锁"><a href="#2：自旋锁" class="headerlink" title="2：自旋锁"></a>2：自旋锁</h2><p>当一个线程获取不到锁的时候会进行阻塞，而阻塞一个线程是需要进行上下文切换，这些都是需要 CPU 进行操作，加入切换一个线程的上下文所需要的时间是 10，而代码的同步快执行一次是 5，那么此时进行线程的上下文切换是不值得</p><p>而现在的 CPU 一般都是多核心处理器，为了提高鲜绿，自选锁也就出现了。两个线程并行执行，让后面那个线程不进入阻塞状态，而是自旋等待 CPU 获取锁。</p><p>在 Java 中的 <code>AtomicInteger</code> 中也是用到了这个特性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">updateAndGet</span><span class="params">(IntUnaryOperator updateFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        next = updateFunction.applyAsInt(prev);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>会一直进行 cas 操作，直至设置成功</p><h3 id="2-1：缺点"><a href="#2-1：缺点" class="headerlink" title="2.1：缺点"></a>2.1：缺点</h3><p>自选锁的缺点就是需要依赖临界资源的执行时间，如果临界资源执行的时间太长，会导致 CPU 时间被浪费</p><h2 id="3：适应性自选锁"><a href="#3：适应性自选锁" class="headerlink" title="3：适应性自选锁"></a>3：适应性自选锁</h2><p>为了弥补自选锁的缺点，在 JDK1.6 里面引入了适应性自选锁，线程的自选状态会根据锁获取的状态以及上一次自选获取锁的时间来决定此次的自选次数</p><h1 id="二、synchronzed"><a href="#二、synchronzed" class="headerlink" title="二、synchronzed"></a>二、synchronzed</h1><p>synchronzed 是 Java 中的一个关键字，由 JVM 负责实现，可以加在代码块、实例方法、静态方法上，加在不同的地方，锁住的对象是不同的。<br>代码块：锁住的是 () 内的对象<br>实例方法：锁住的是当前对象实例<br>静态方法：锁住的是当前对象的Class</p><p>synchronzed 具有原子性、互斥性、可重入性、不可中断性</p><h2 id="1：原子性"><a href="#1：原子性" class="headerlink" title="1：原子性"></a>1：原子性</h2><p>首先来解释下原子性的定义：一个操作要么全部执行完成，不执行。<br>那么 synchronized 是如何保证的呢？<br>synchronized 修饰的代码块或者方法，在同一个时刻，只有一个线程可以获得锁并执行，其他线程只能等锁释放以后才可以执行，否则会阻塞。<br>这样就保证了在同一个时刻，只有一个线程可以对变量进行修改，保证了原子性</p><h2 id="2：可重入性"><a href="#2：可重入性" class="headerlink" title="2：可重入性"></a>2：可重入性</h2><p>对于同一个线程加的锁，该线程可以在任何时间再次执行同步代码块内部的方法</p><h2 id="3：实现细节"><a href="#3：实现细节" class="headerlink" title="3：实现细节"></a>3：实现细节</h2><p>如果对实例方法或者静态方法加锁，在编译后的 class 文件会出现两个 flag，代表这个方法是一个同步方法，其他线程在执行这个方法的时候必须获得锁<br>如果修饰的是实例方法或者静态方法，那么在反编译的字节码里面可以看到如下这个关键字：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/difference%20between%20synchronized%20and%20volatile/ACC_SYNCHRONIZED%402x.png" alt=""></p><p>如果修饰的是代码块，那么编译成字节码后的代码如下：</p><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/difference%20between%20synchronized%20and%20volatile/monitor_enter_exit.png" alt=""></p><h3 id="3-1：MarkWord"><a href="#3-1：MarkWord" class="headerlink" title="3.1：MarkWord"></a>3.1：MarkWord</h3><p>在谈及 synchronized 的时候，先了解下 MarkWord，Java 的对象头由三部分组成：Mark World、对象引用指针、数组长度（数组才有）</p><p>而 synchronized 的一些操作主要就在 MarkWord 中</p><p>下面是来自于 markOop.hpp 中关于 MarkWord 区域的描述<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  32 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//  hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//  size:32 ------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//  PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  64 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//  size:64 -----------------------------------------------------&gt;| (CMS free block)</span></span><br></pre></td></tr></table></figure></p><p>如果画成图则是如下形式<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/difference%20between%20synchronized%20and%20volatile/32.png" alt="32位机器"><br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/difference%20between%20synchronized%20and%20volatile/64.png" alt="64位机器"></p><h3 id="3-2：加锁过程"><a href="#3-2：加锁过程" class="headerlink" title="3.2：加锁过程"></a>3.2：加锁过程</h3><p>synchronized 在 JDK1.6 之后的到了明显的优化，由之前的直接到重量级锁变为如下几个步骤：</p><p>无锁、偏向锁、轻量级锁、重量级锁</p><h3 id="3-3无锁"><a href="#3-3无锁" class="headerlink" title="3.3无锁"></a>3.3无锁</h3><p>这是最理想的情况，当处于无锁的状态下时，Mark World 存放的是对象的 hashCode，以及当前对象的分代年龄。这里所说的 HashCode 指的是一致性 HashCode，也就是通过 Object::hashCode 或者 System::identityHashCode(Object) 方法 得到的</p><blockquote><p>关于一致性 HashCode：</p></blockquote><p>因为一致性 HashCode 是一个随机数，第二次计算肯定与第一次计算得到不同的结果，而在 JVM 中一个对象的 HashCode 前后调用需要保持一致，所以这也是为什么一个对象生成过一致性 HashCode 以后便无法再次进入偏向锁状态</p><p>而如果一个对象正处于偏向锁状态，但是立即收到了重新计算一致性 HashCode 的请求，那么此时就会马上被膨胀为重量级锁</p><h3 id="3-4偏向锁："><a href="#3-4偏向锁：" class="headerlink" title="3.4偏向锁："></a>3.4偏向锁：</h3><p>引入偏向锁的目的是为了解决多线程竞争不激烈的情况下，例如一个程序在大多数情况下只有一个线程进行一次或者多次的访问，对于这种情况，就没必要进行加锁的操作了。在 JDK6 之前，synchronized 之所以性能很差和每次加锁都是重量级锁有关</p><p>持有偏向锁的线程不会主动的撤销自己所持有的偏向锁，如果此时发生了竞争，那么当前的业务线程需要向 VmThread 请求进入到全局的安全点，一旦进入到安全点，就会尝试撤销偏向锁，如果此时发现之前持有偏向锁的线程已经退出同步代码块或者已经结束，则直接进行 CAS 替换 MarkWord 的 ThreadId。</p><p>否则，此时会将偏向锁撤销，并且设置锁标记为轻量级锁，持有偏向锁的线程不会主动的撤销偏向锁<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ObjectSynchronizer::fast_enter(Handle obj, BasicLock* lock, <span class="keyword">bool</span> attempt_rebias, TRAPS) &#123;</span><br><span class="line"> <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!SafepointSynchronize::is_at_safepoint()) &#123;</span><br><span class="line">      BiasedLocking::Condition cond = BiasedLocking::revoke_and_rebias(obj, attempt_rebias, THREAD);</span><br><span class="line">      <span class="comment">// 如果是已经撤销并且重新偏向成功，直接返回</span></span><br><span class="line">      <span class="keyword">if</span> (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果已经在安全点，已经发生竞争，直接尝试撤销并且升级</span></span><br><span class="line">      assert(!attempt_rebias, <span class="string">"can not rebias toward VM thread"</span>);</span><br><span class="line">      BiasedLocking::revoke_at_safepoint(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!obj-&gt;mark()-&gt;has_bias_pattern(), <span class="string">"biases should be revoked by now"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 升级轻量级锁</span></span><br><span class="line"> slow_enter (obj, lock, THREAD) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-5轻量级锁："><a href="#3-5轻量级锁：" class="headerlink" title="3.5轻量级锁："></a>3.5轻量级锁：</h3><p>如果一个锁需要升级为轻量级锁，会进行如下操作：</p><p>首先检查是否是无锁状态，如果是的话，则在当前的线程栈桢里面新建一个 LockRecord 的记录，官方命名为 displaced mark，<br>然后将对象的 MarkWord 拷贝一份进 displaced mark，再通过 CAS 操作将对象中的 MarkWord 指针更新为 LockRecord 的地址，并且将 LockRecord 中的 owner 更新为原 MarkWord</p><p>如果是已经有锁的状态下，会检查对象的 MarkWord 指针是否指向自己的一个栈桢，如果是的话，则代表是自己重入，那么直接执行即可</p><p>否则会进行自旋，如果达到一定的阈值后，还无法获取到锁，则直接升级为重量级锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) &#123;</span><br><span class="line">  markOop mark = obj-&gt;mark();</span><br><span class="line">  <span class="comment">// 必须是非偏向锁状态</span></span><br><span class="line">  assert(!mark-&gt;has_bias_pattern(), <span class="string">"should not see bias pattern here"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否有锁，如果 JVM 没有开启偏向锁，那么此时可能会一种无锁的状态</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;is_neutral()) &#123;</span><br><span class="line">    <span class="comment">// Anticipate successful CAS -- the ST of the displaced mark must</span></span><br><span class="line">    <span class="comment">// be visible &lt;= the ST performed by the CAS.</span></span><br><span class="line">    <span class="comment">// 设置 displaced MarkWord</span></span><br><span class="line">    lock-&gt;set_displaced_header(mark);</span><br><span class="line">    <span class="keyword">if</span> (mark == (markOop) Atomic::cmpxchg_ptr(lock, obj()-&gt;mark_addr(), mark)) &#123;</span><br><span class="line">      TEVENT (slow_enter: release stacklock) ;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Fall through to inflate() ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark-&gt;locker())) &#123;</span><br><span class="line">    assert(lock != mark-&gt;locker(), <span class="string">"must not re-lock the same lock"</span>);</span><br><span class="line">    assert(lock != (BasicLock*)obj-&gt;mark(), <span class="string">"don't relock with same BasicLock"</span>);</span><br><span class="line">    lock-&gt;set_displaced_header(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="comment">// The following optimization isn't particularly useful.</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;has_monitor() &amp;&amp; mark-&gt;monitor()-&gt;is_entered(THREAD)) &#123;</span><br><span class="line">    lock-&gt;set_displaced_header (<span class="literal">NULL</span>) ;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The object header will never be displaced to this lock,</span></span><br><span class="line">  <span class="comment">// so it does not matter what the value is, except that it</span></span><br><span class="line">  <span class="comment">// must be non-zero to avoid looking like a re-entrant lock,</span></span><br><span class="line">  <span class="comment">// and must not look locked either.</span></span><br><span class="line">  lock-&gt;set_displaced_header(markOopDesc::unused_mark());</span><br><span class="line">  ObjectSynchronizer::inflate(THREAD, obj())-&gt;enter(THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>升级为轻量级锁以后，竞争锁的线程会自旋几次，避免升级至重量级锁，这个自旋次数不是一个固定值，而是由 JVM 动态来决定的</p><p>如果自旋次数达到阈值，那么会直接升级为重量级锁，或者 JVM 判断之前几次自旋都没有获取到锁，那么也就不用再自选了，因此可能会直接升级到重量级锁</p><h3 id="3-6重量级锁"><a href="#3-6重量级锁" class="headerlink" title="3.6重量级锁"></a>3.6重量级锁</h3><p>重量级锁是通过 mutex 来实现的，锁的状态会被改成「10」，并且 MarkWord 里面存储的是指向重量级锁的指针，所有等待的线程都会被挂起</p><h1 id="三、volatile"><a href="#三、volatile" class="headerlink" title="三、volatile"></a>三、volatile</h1><p>volatile 和 synchronized 不同的是，volatile 只有可见性，没有互斥性</p><h2 id="1可见性"><a href="#1可见性" class="headerlink" title="1可见性"></a>1可见性</h2><p>在计算机发展的早前，CPU 多是单核的，虽然仍然可以并发的执行程序，但是不会存在可见性问题，因为所有的数据要么存在于内存中，要么存在于 CPU 的缓存中，所以任何线程在数据写入和读取的时候一定都是从同一个地方获取的。</p><p>随着计算机的发展，多核心的 CPU 出现了，这个时候程序执行的速度可以加快，但是前辈们发现计算机从内存中获取数据的速度依然很慢，因此考虑要不要直接在 CPU 内部做一个缓存，将内存中的数据和指令批量读取一部分来到 CPU 本地来，然后进行处理，最后将处理完数据再回写到内存中</p><p>但是这样就会产生一个可见性问题：假设有两个 CPU 同时将一个变量 a++  读取到了自己的 CPU 缓存中，同时执行了指令 +1，于是在回写的时候，都将 a 的值写为 1 了，但是程序正常执行的话，a 的值应该是 2，而不是1</p><h3 id="1-1总线加锁"><a href="#1-1总线加锁" class="headerlink" title="1.1总线加锁"></a>1.1总线加锁</h3><blockquote><p>总线是与所有 CPU 相连接的一个主线路，可以理解为所有的 CPU 指令都必须经过总线<br>当一个 CPU 读取变量 a 到自己本地的时候，会向总线发送一个 LOCK 信号，此时其他 CPU 便会暂停执行，直至第一个 CPU 执行完毕</p></blockquote><h3 id="1-2MESI-协议"><a href="#1-2MESI-协议" class="headerlink" title="1.2MESI 协议"></a>1.2MESI 协议</h3><p>MESI 是一种基于实效的缓存一致性协议，通俗来说就是当一个 CPU 修改了一个变量的值以后，其他的 CPU 会立马感知到并且将自己的本次缓存设置为无效，而 MESI 对应的四个状态分别是<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/difference%20between%20synchronized%20and%20volatile/mesi.png" alt=""></p><p>每一次 CPU 从内存中读取数据的时候，都会向其他 CPU 发送一个事件，其他 CPU 接收到该事件以后，都会给到相应。<br>关于向消息总线发送的消息，感兴趣的话可以去看下<a href="https://zh.wikipedia.org/wiki/MESI%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">维基百科</a></p><h2 id="2禁止重排序"><a href="#2禁止重排序" class="headerlink" title="2禁止重排序"></a>2禁止重排序</h2><p>volatile 关键字还有一个作用就是禁止重排序，该实现该功能依赖于内存屏障，在 hotspot 中，内存屏障如下有如下几个：<br>LoadLoad、LoadStore、StoreLoad、StoreStore</p><p>而在 openJdk 里面，对这几个屏障有很详细的描述<a href="https://github.com/openjdk/jdk/blob/6bab0f539fba8fb441697846347597b4a0ade428/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.code/src/jdk/vm/ci/code/MemoryBarriers.java" target="_blank" rel="noopener">openJdk关于这几个的描述</a></p><p>在 Java 中，对于这几个命令可以简化为如下：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/difference%20between%20synchronized%20and%20volatile/memory_barrier.png" alt=""><br>该图表示的是在第一个操作之后，JVM 需要在第二个操作之前加入的一个内存屏障，正是这些操作才会使得 volatile 可以拥有禁止重排序的功能</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、锁&quot;&gt;&lt;a href=&quot;#一、锁&quot; class=&quot;headerlink&quot; title=&quot;一、锁&quot;&gt;&lt;/a&gt;一、锁&lt;/h1&gt;&lt;p&gt;从细节上来说，锁分为 乐观锁、悲观锁&lt;/p&gt;
&lt;p&gt;乐观锁适用于读多写少的场景，一般是通过 CAS 进行操作，因为不用加锁，所以性能
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LockSupport的一些琐事</title>
    <link href="https://somersames.github.io/2021/05/16/LockSupport%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%90%E4%BA%8B/"/>
    <id>https://somersames.github.io/2021/05/16/LockSupport的一些琐事/</id>
    <published>2021-05-16T15:46:07.000Z</published>
    <updated>2021-05-17T16:31:18.327Z</updated>
    
    <content type="html"><![CDATA[<p>LockSupport 是一个用于线程阻塞或者唤醒的类，位于 rt.jar，主要是通过 Unsafe 类来进行操作</p><p>该类的方法都是静态方法，最常使用的方法是 void park(Object blocker) 和 void unpark(Thread thread)</p><p>是AQS操作的基础类，阻塞线程的时候不需要加锁，比较方便</p><p>下面主要介绍这两种方法：</p><h2 id="void-park-Object-blocker"><a href="#void-park-Object-blocker" class="headerlink" title="void park(Object blocker)"></a>void park(Object blocker)</h2><p>这个方法和 void park() 类似，最主要的区别在于 void park(Object blocker) 设置了一个 blocker，这个参数是一个 Object，一般是当前对象放进去，尤其是需要通过 jstack 查看线程阻塞的原因，此时会打印block<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/LockSupport_something/Jstack_Thread.png" alt=""></p><h2 id="void-unpark-Thread-thread"><a href="#void-unpark-Thread-thread" class="headerlink" title="void unpark(Thread thread)"></a>void unpark(Thread thread)</h2><p>该方法会将一个处于阻塞状态的线程唤醒，可以将「许可」理解为一个信号量<br>如果当前的没有信号量，则 unpark 会将设置一个，如果有一个信号量，则 unpark 也不会进行任何操作，因为LockSupport 所允许的信号量仅允许一个</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>该类有一个特点就是，阻塞线程不需要在同步代码块里面</p><blockquote><p>如果是 Object.wait()，需要在 synchronized 同步块里面的</p></blockquote><p>唤醒一个由 park 方法阻塞的线程，被唤醒的线程是不知道由于何种原因导致的，例如唤醒它的方法有如下几种：</p><ol><li>另一个线程调用了 unpark 方法</li><li>另一个线程调用了中断函数</li><li>阻塞的时间到了，自动唤醒<br>被阻塞的线程可以由于上述任何一个原因被唤醒，但是唤醒之后如果要知道唤醒原因，除了第二种可以通过 <code>isInterrupted</code> 知道，其余两种均无法获知</li></ol><h2 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h2><p>为了避免虚假唤醒，最好是在 while 里面调用 park 方法，同时 park 和 unpark 需要配对使用，但是需要注意不要在调用 park 方法之前调用 unpark 方法，避免导致 park 不会阻塞</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;LockSupport 是一个用于线程阻塞或者唤醒的类，位于 rt.jar，主要是通过 Unsafe 类来进行操作&lt;/p&gt;
&lt;p&gt;该类的方法都是静态方法，最常使用的方法是 void park(Object blocker) 和 void unpark(Thread thre
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jackson中的范型</title>
    <link href="https://somersames.github.io/2021/04/16/jackson%E4%B8%AD%E7%9A%84%E8%8C%83%E5%9E%8B/"/>
    <id>https://somersames.github.io/2021/04/16/jackson中的范型/</id>
    <published>2021-04-16T15:27:27.000Z</published>
    <updated>2021-04-27T17:18:50.684Z</updated>
    
    <content type="html"><![CDATA[<p>在 jackson 将字符串转为对象的时候，如果是不带有范型的数据类，那么在 strig 转 obj 的时候不会出现什么问题，如果你的对象带有范型的话，那么就需要注意了，稍不注意就会抛出如下异常</p><blockquote><p>java.util.LinkedHashMap cannot be cast to XX</p></blockquote><p>出现该原因的原因在于 jackson 转换对象的时候，如果没有识别到原始类型，会默认将其转为 LinkedHashMap，后续一旦使用该类，就会抛出上述错误<br>demo如下：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/typeReference_in_jackson/Food.png" alt=""><br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/typeReference_in_jackson/Apple.png" alt=""></p><p>如果你是使用如下方法进行 string 转 object，那么范型会被映射称为 <code>LinkedHashMap</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(String content, Class&lt;T&gt; valueType)</span></span></span><br></pre></td></tr></table></figure></p><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/typeReference_in_jackson/Food_strToObj.png" alt=""></p><h1 id="一、jackson-是如何赋值的（默认构造器和多参数构造器）"><a href="#一、jackson-是如何赋值的（默认构造器和多参数构造器）" class="headerlink" title="一、jackson 是如何赋值的（默认构造器和多参数构造器）"></a>一、jackson 是如何赋值的（默认构造器和多参数构造器）</h1><h2 id="无参构造器"><a href="#无参构造器" class="headerlink" title="无参构造器"></a>无参构造器</h2><p>对于含有无参数构造器的对象，那么处理流程很简单，就是直接通过 <code>_defaultCreator.call()</code> 来进行对象的创建，通过 <code>newInstance()</code> 来实例化，最后通过反射 invoke 方法进行赋值</p><h2 id="有参数构造器"><a href="#有参数构造器" class="headerlink" title="有参数构造器"></a>有参数构造器</h2><p>如果含有多个构造函数，那么就必须指明需要用哪一个构造函数进行初始化，否则代码会直接报错</p><blockquote><p>no Creators, like default constructor, exist</p></blockquote><p>很明显，这个表示没有指定一个构造器作为 Jackson 实例化使用，因为对于多参数构造器，Jackson 不知道用赋值的顺序，所以需要人为进行指定<br>但是如果是两个 String 的入参，那么如何进行字段映射？，其实 jackson 还是不知道</p><p>这个时候就需要指定一个构造器了<code>@JsonCreator</code>，配合 <code>@JsonProperty</code> 指定字段。<br>因为对于多个参数的构造器，需要明确告诉 Jackson 如何对其进行赋值，否则会抛出以下错误</p><blockquote><p>Argument #0 of constructor [constructor for <code>xyz.somersames.model.Producer</code> (3 args)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonCreator</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(@JsonProperty(<span class="string">"name"</span>)</span> String name, @<span class="title">JsonProperty</span><span class="params">(<span class="string">"age"</span>)</span> String age, @<span class="title">JsonProperty</span><span class="params">(<span class="string">"friend"</span>)</span> T friend) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.friend = friend;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、范型擦除"><a href="#二、范型擦除" class="headerlink" title="二、范型擦除"></a>二、范型擦除</h1><p>如果你在代码中这样写，在编译期间都是不通过的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testType</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Food&lt;Apple&gt; food = <span class="keyword">new</span> Food&lt;Apple&gt;();</span><br><span class="line">    Food&lt;LinkedHashMap&gt; linkedHashMapFood = <span class="keyword">new</span> Food&lt;LinkedHashMap&gt;();</span><br><span class="line">    food = linkedHashMapFood;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么为什么在运行期间可以将 LinkedHashMap 赋值到 food 上去呢，这就是范型擦除，在运行的时候 JVM 其实是不知道你的范型类型的<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/typeReference_in_jackson/Food_strToObj.png" alt=""></p><p>但是在 Jackson 是可以实现范型的转换，那么就要在运行期间获取到该类的原始类型，官方推荐如下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">readValue</span><span class="params">(String content, TypeReference&lt;T&gt; valueTypeRef)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//demo</span></span></span><br><span class="line"><span class="function">objectMapper.<span class="title">readValue</span><span class="params">(<span class="string">"XXX"</span>, new TypeReference&lt;XXX&gt;()</span> </span>&#123;&#125;);</span><br></pre></td></tr></table></figure></p><p>TypeReference 是一个抽象方法，如果你的 java 基础还可以的话，一眼就可以看到这就是一个匿名内部类，匿名内部类其实可以带有范型的原始信息的</p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>如果一个类中含有匿名内部类，那么在编译以后会形成两个 class 文件的，demo 如下：</p><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/typeReference_in_jackson/TestA.png" alt=""></p><p>在编译以后会生成两个文件<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/typeReference_in_jackson/class_TestA.png" alt=""><br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/typeReference_in_jackson/class_TestA1.png" alt=""></p><p>很明显，第二个 class 文件是带有原始的信息的，这说明匿名内部类是可以继承自原始类型的</p><blockquote><p>PS：这一点其实和 JDK 的动态代理类似，都是通过新生成一个 class 文件，但是作用却是不同的</p></blockquote><h2 id="JackSon-获取原始类型"><a href="#JackSon-获取原始类型" class="headerlink" title="JackSon 获取原始类型"></a>JackSon 获取原始类型</h2><p>下面我以一个简单的例子来表示这两者的区别：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/typeReference_in_jackson/TestB.png" alt=""></p><p>打印结果如下：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/typeReference_in_jackson/TestB_Print.png" alt=""></p><p>注意红框内部的区别，可以看到 ListWithInit 里面是一个匿名内部类，而上面所说了匿名内部类是会重新生成一个class文件的，从而导致 <code>ListWithInit</code> 是可以拿到范型信息的，<br>把 B 编译以后生成的 B$1.class 代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>$1 <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    B$<span class="number">1</span>(B var1) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = var1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到编译后的 class 文件实际上已经把原始的范型信息包含了，而普通的 ArrayList 因为其父类还是 <code>AbstractList&lt;E&gt;</code>，所以在运行期间是拿不到原始的范型信息的</p><p>最后在 JDK 中通过 <code>getActualTypeArguments</code> 就可以拿到范型了</p><h1 id="三、反射设置范型"><a href="#三、反射设置范型" class="headerlink" title="三、反射设置范型"></a>三、反射设置范型</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class clazz = Class.forName(<span class="string">"xyz.somersames.demo.Food"</span>);</span><br><span class="line">    Food&lt;Apple&gt; food = <span class="keyword">new</span> Food&lt;Apple&gt;();</span><br><span class="line">    Method m1 = clazz.getDeclaredMethod(<span class="string">"setT"</span>,Object.class);</span><br><span class="line">    m1.invoke(food,<span class="keyword">new</span> LinkedHashMap&lt;String,String&gt;());</span><br><span class="line">    System.out.println(food.getT());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实说了那么多，Jackson 的转换大致流程就是先通过构造器来进行对象的实例化，最后通过反射进行字段的赋值操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 jackson 将字符串转为对象的时候，如果是不带有范型的数据类，那么在 strig 转 obj 的时候不会出现什么问题，如果你的对象带有范型的话，那么就需要注意了，稍不注意就会抛出如下异常&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;java.util.LinkedHas
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring ContentNegotiation（内容协商）之原理篇（二）</title>
    <link href="https://somersames.github.io/2021/04/10/talkabout-httpMessageConvert-2/"/>
    <id>https://somersames.github.io/2021/04/10/talkabout-httpMessageConvert-2/</id>
    <published>2021-04-10T15:31:38.000Z</published>
    <updated>2021-04-14T16:48:14.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在了解这部分之前，你需要知道 Spring 都是通过 DispatcherServlet 来处理和分发请求的，如果不知道的话也不会影响到本文的阅读</p><p>在开启内容协商之后，URL 肯定是会变的，例如之前是 a/b，开启后则变成为 a/b.json 或者 a/b.xml</p><p>那么 Spring 首先第一步就需要解决如何将这个 url 映射到正确的 Controller 上的呢？</p><h2 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h2><p>在 Spring 5.X 中，目前只含有 5 种，分别如下<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/talkaboutHttpMeesageConvert2/five_handle_mapping.png" alt=""><br>如果你没有做任何操作，那么用于处理 Controller 的请求就是来自于 <code>RequestMappingHandlerMapping</code>，如果你想把<code>/*/a，/a*</code> 映射到指定的 Controller，那么可以了解下 <code>SimpleUrlHandlerMapping</code>，当然这些都是后话了，与本文无关</p><p>获取 <code>HandlerMapping</code> 最重要的一个原因是要拿到 <code>HandlerExecutionChain</code>，在 HandlerExecutionChain 里面有我们熟悉的拦截器以及处理请求的 Handle，<br>获取 Handle 后通过 getHandlerAdapter 来获取最终的 HandlerAdapter，通过 HandlerAdapter.handle(HttpServletRequest request, HttpServletResponse response, Object handler) 来处理请求</p><p>具体的作用如图<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/talkaboutHttpMeesageConvert2/simple-http-handle.png" alt=""></p><h2 id="HandlerExecutionChain"><a href="#HandlerExecutionChain" class="headerlink" title="HandlerExecutionChain"></a>HandlerExecutionChain</h2><p>HandlerExecutionChain 内部没有很多的属性，主要都是拦截器相关，既然拦截器执行是在获取到 HandlerExecutionChain 之后执行的，那么匹配 Url 肯定是在这之前，所以只需要看 getHandler 就可以了</p><h1 id="getHandler"><a href="#getHandler" class="headerlink" title="getHandler"></a>getHandler</h1><p>getHandler 是 HandlerMapping 接口的一个抽象方法，在 AbstractHandlerMapping 中被实现，主要功能是匹配该 Request 对应的 HandlerExecutionChain<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/talkaboutHttpMeesageConvert2/getHandle.png" alt=""></p><p>这里 getHandlerInternal 返回的是一个 HandlerMethod，打印出来如下：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/talkaboutHttpMeesageConvert2/HandleMethod.png" alt=""></p><p>可以看到这里返回的其实就是对应的Controller 处理方法，那么 mapping 肯定就在这个方法内部，在这个方法里面有一个很重要的方法 lookupHandlerMethod，该方法就是最终进行匹配的地方</p><h2 id="lookupHandlerMethod"><a href="#lookupHandlerMethod" class="headerlink" title="lookupHandlerMethod"></a>lookupHandlerMethod</h2><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/talkaboutHttpMeesageConvert2/lookupHandlerMethod.png" alt=""><br>在进行下去会看到 AbstractHandlerMethodMapping 的 addMatchingMappings 方法，该方法就是会对所有该项目的所有的url进行依一一匹配<br>最终会调用到 getMatchingCondition 方法，而我们仅仅需要对 getMatchingCondition 关注即可，因为前面的判断并不会跟内容协商有关<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/talkaboutHttpMeesageConvert2/getMatchingCondition.png" alt=""></p><p>getMatchingCondition 最终会调用的 PatternsRequestCondition 的 getMatchingPattern 方法，这个方法也就是今天的核心了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PatternsRequestCondition <span class="title">getMatchingCondition</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.patterns.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String lookupPath = <span class="keyword">this</span>.pathHelper.getLookupPathForRequest(request);</span><br><span class="line">    List&lt;String&gt; matches = getMatchingPatterns(lookupPath);</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>matches 里面存储的事所有匹配到的 url，这个url 并不是原始的，而是匹配后的，例如 <code>a/b/c.*</code> </p><p>对于内容协商，则只需要关心 <code>this.patternsCondition.getMatchingCondition(request)</code> 即可，而该方法最终会进入 <code>PatternsRequestCondition#getMatchingPattern</code><br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/talkaboutHttpMeesageConvert2/getMatchingPattern.png" alt=""></p><p>如果你开启的是后缀匹配模式，那么 <code>this.useSuffixPatternMatch</code> 就必须是true，这也是上面说的 tips，上图红框内代码会判断下，如果是后缀匹配，那么 url 里面肯定是会有一个 . 的，所以此时用 . 进行区分，也就是如果你的 url 是 <code>a/b/c</code>，请求的url 是 <code>a/b/c.json</code>，此时就会通过 <code>a/b/c.*</code> 和 <code>a/b/c.json</code> 进行匹配，可想而知，肯定可以匹配到的，所以此时就可以找到正确的处理方法了，也就是会返回 <code>a/b/c.*</code> 作为匹配到的 url</p><p>那么既然匹配到 url 是 a/b/c.*，那么在 controller 中的 url 又是如何映射过去的呢？<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/talkaboutHttpMeesageConvert2/addMatchingMappings2.png" alt=""></p><p>答案是在这个 for 循环里面，在进行遍历的时候，那个 mapping 就是原始的 controller 中的 url 方法，所以 spring 才可以通过这个定位到是通过哪个方法来处理该请求</p><p>当获取到 HandlerMethod 之后，则 通过 getHandlerExecutionChain 来获取所有的拦截器，并且进行处理，如果拦截器返回 false，则直接 return，否则通过 HandlerAdapter 来进行处理请求</p><h1 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h1><p>既然已经知道了调用的方法，那么最后就是通过 url 的后缀来匹配对应的 HandlerMethodReturnValueHandler</p><h2 id="HandlerMethodReturnValueHandler"><a href="#HandlerMethodReturnValueHandler" class="headerlink" title="HandlerMethodReturnValueHandler"></a>HandlerMethodReturnValueHandler</h2><p>这是一个抽象接口，里面只有两个抽象放啊，分别如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMethodReturnValueHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(@Nullable Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>supportsReturnType 判断该 Handle 能否处理该请求，handleReturnValue 则是真正处理该请求返回值的方法</p><h3 id="RequestResponseBodyMethodProcessor"><a href="#RequestResponseBodyMethodProcessor" class="headerlink" title="RequestResponseBodyMethodProcessor"></a>RequestResponseBodyMethodProcessor</h3><p>这个类是专门用来处理用 ResponseBody 注解修饰的方法，其 supportsReturnType 如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ResponseBody.class) ||</span><br><span class="line">            returnType.hasMethodAnnotation(ResponseBody.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="writeWithMessageConverters"><a href="#writeWithMessageConverters" class="headerlink" title="writeWithMessageConverters"></a>writeWithMessageConverters</h2><p>该方法位于 AbstractMessageConverterMethodProcessor，关键代码如图：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/talkaboutHttpMeesageConvert2/addMatchingMappings2.png" alt=""></p><p>getAcceptableMediaTypes 就是来判断该 url 适合用什么格式来解析的关键代码，具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;MediaType&gt; <span class="title">getAcceptableMediaTypes</span><span class="params">(HttpServletRequest request)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> HttpMediaTypeNotAcceptableException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.contentNegotiationManager.resolveMediaTypes(<span class="keyword">new</span> ServletWebRequest(request));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>继续往下跟，到了 getMediaTypeKey 也就最后不远了，getMediaTypeKey 是 PathExtensionContentNegotiationStrategy 下的一个方法，主要是获取 url 里面所支持的 MediaType，<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/talkaboutHttpMeesageConvert2/getMediaTypeKey.png" alt=""></p><p>通过 <code>UriUtils.extractFileExtension(path)</code> 是可以拿到 /a/b/c.json 后面的 json，具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">extractFileExtension</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> end = path.indexOf(<span class="string">'?'</span>);</span><br><span class="line">    <span class="keyword">int</span> fragmentIndex = path.indexOf(<span class="string">'#'</span>);</span><br><span class="line">    <span class="keyword">if</span> (fragmentIndex != -<span class="number">1</span> &amp;&amp; (end == -<span class="number">1</span> || fragmentIndex &lt; end)) &#123;</span><br><span class="line">        end = fragmentIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (end == -<span class="number">1</span>) &#123;</span><br><span class="line">        end = path.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> begin = path.lastIndexOf(<span class="string">'/'</span>, end) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> paramIndex = path.indexOf(<span class="string">';'</span>, begin);</span><br><span class="line">    end = (paramIndex != -<span class="number">1</span> &amp;&amp; paramIndex &lt; end ? paramIndex : end);</span><br><span class="line">    <span class="keyword">int</span> extIndex = path.lastIndexOf(<span class="string">'.'</span>, end);</span><br><span class="line">    <span class="keyword">if</span> (extIndex != -<span class="number">1</span> &amp;&amp; extIndex &gt; begin) &#123;</span><br><span class="line">        <span class="keyword">return</span> path.substring(extIndex + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="favorParameter-format模式"><a href="#favorParameter-format模式" class="headerlink" title="favorParameter format模式"></a>favorParameter format模式</h1><p>这个模式在处理请求的部分大同小异，主要是在解析返回的 MediaTypeKey 上有区别<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/talkaboutHttpMeesageConvert2/getMediaTypeKey_parameter.png" alt=""><br>直接解析指定的参数，拿到对应的格式，一切就都结束了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在了解这部分之前，你需要知道 Spring 都是通过 DispatcherServlet 来处理和分发请求的，如果不知道的话也不会影响到本文
      
    
    </summary>
    
      <category term="Springboot" scheme="https://somersames.github.io/categories/Springboot/"/>
    
    
      <category term="Springboot" scheme="https://somersames.github.io/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>Spring ContentNegotiation（内容协商）之使用篇（一）</title>
    <link href="https://somersames.github.io/2021/04/07/talk-about-httpMessageConvert/"/>
    <id>https://somersames.github.io/2021/04/07/talk-about-httpMessageConvert/</id>
    <published>2021-04-06T16:11:11.000Z</published>
    <updated>2021-04-14T17:11:15.419Z</updated>
    
    <content type="html"><![CDATA[<!-- 提纲：一旦匹配不到就会走默认逻辑，具体的处理逻辑是之所以配置文件请求url为json1，也可以返回json，是因为没有指定默认的返回格式，但是spring的默认是 */*，而spring的 json 的 convert 恰好又可以解析这种格式，所以就会导致除非可以匹配到，没有匹配到的全部都会转为json当配置了第二种方式以后会通过 ParameterContentNegotiationStrategy 来解析Parameter发现的另一个坑不要开启 @EnableMVC，否则会导致mvc的部分配置失效 --><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>随着业务系统的成熟，如果你的项目正好是公司的中台战略之一，但是下游系统的接收方式不统一，这一种情况在一些老的公司系统架构总经常出现，如果下游系统不方便兼容，那么就需要中台系统对外提供各种不同格式返回报文</p><h2 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h2><p>简单说就是服务提供方根据客户端所支持的格式来返回对应的报文，在 Spring 中，REST API 基本上都是以 json 格式进行返回，而如果需要一个接口即支持 json，又支持其他格式，开发和维护多套代码显然是不合理的，而 Spring 又恰好提供了该功能，那便是ContentNegotiation</p><p>在 Spring 中，决定一个数据是以 json、xml 还是 html 的方式返回有三种方式，分别如下：</p><blockquote><p>1：favorPathExtension 后缀模式，例如：xxx.json，xxx.xml<br>2：favorParameter format模式，例如：xxx?format=json,xxx?format=xml,<br>3：通过请求的 Accept 来决定返回的值</p></blockquote><p>在这三种模式中，前面两种模式都是关闭，如果需要打开，可以通过以下方式来开启<br>1：重写 <code>WebMvcConfigurer</code>(Spring5.X以后推荐的实现类) 的 <code>configureContentNegotiation</code> 来设置为 true 即可<br>2：设置 spring.mvc.contentnegotiation.favor-path-extension=true 或者 pring.mvc.contentnegotiation.favor-parameter=true</p><blockquote><p>tips:如果是使用 Spring2.X以上的版本，不要开启 @EnableWebMvc 注解，否则会导致你的配置无效，如果需要开启该注解，则只能使用方法一重写 WebMvcConfigurer 了<br>并且还需要说明一点的是通过配置文件开启的话，需要设置 useSuffixPattern 为 true，重写 <code>configureContentNegotiation</code> 的已经默认为 true 了</p></blockquote><h1 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h1><h2 id="1：favorPathExtension-后缀模式"><a href="#1：favorPathExtension-后缀模式" class="headerlink" title="1：favorPathExtension 后缀模式"></a>1：favorPathExtension 后缀模式</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  mvc:</span></span><br><span class="line"><span class="attr">    contentnegotiation:</span></span><br><span class="line"><span class="attr">      favor-path-extension:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      media-types:</span></span><br><span class="line"><span class="attr">        json:</span> <span class="string">application/json</span></span><br></pre></td></tr></table></figure><p>favor-path-extension 表示是否开启后缀匹配，media-types 表示后缀以何种方式进行解析，在这里需要注意一下一定是需要有对应的 HttpMessageConvert 才能解析，否则是会提示 <code>406 Could not find acceptable representation</code></p><blockquote><p>在 Spring 中已经默认含有json解析的 HttpMessageConvert，所以是可以直接解析的，如果需要支持解析 xml，可以引入 xml 包</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当开启了后缀模式以后，返回的文本类型会根据你的入参做不同的处理，.json 会返回 json 格式的数据，.xml 会返回 xml 格式的数据，当然也可以自定义一个 HttpMessageConverter 来自定义的返回文本格式</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET localhost:8081/controller/advice/decrypt.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    "name": "a",</span><br><span class="line">    "age": 1,</span><br><span class="line">    "date": null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET localhost:8081/controller/advice/decrypt.xml</span><br><span class="line"></span><br><span class="line">&lt;Advice&gt;</span><br><span class="line">    &lt;name&gt;a&lt;/name&gt;</span><br><span class="line">    &lt;age&gt;1&lt;/age&gt;</span><br><span class="line">    &lt;date/&gt;</span><br><span class="line">&lt;/Advice&gt;</span><br></pre></td></tr></table></figure><h2 id="2：favorParameter"><a href="#2：favorParameter" class="headerlink" title="2：favorParameter"></a>2：favorParameter</h2><p>这种模式下是通过在 url 中通过一个参数来区分如何解析的，spring中已经默认这个关键字是 <code>format</code></p><p>修改配置文件如下：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  mvc:</span></span><br><span class="line"><span class="attr">    contentnegotiation:</span></span><br><span class="line"><span class="attr">      favor-parameter:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET localhost:8081/controller/advice/decrypt?format=json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    "name": "a",</span><br><span class="line">    "age": 1,</span><br><span class="line">    "date": null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET localhost:8081/controller/advice/decrypt?format=xml</span><br><span class="line"></span><br><span class="line">&lt;Advice&gt;</span><br><span class="line">    &lt;name&gt;a&lt;/name&gt;</span><br><span class="line">    &lt;age&gt;1&lt;/age&gt;</span><br><span class="line">    &lt;date/&gt;</span><br><span class="line">&lt;/Advice&gt;</span><br></pre></td></tr></table></figure><p>当然也可以自己修改 parameter 的关键字，只需要在配置文件中调整下即可<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">parameter-name:</span> <span class="string">meida_type</span></span><br></pre></td></tr></table></figure></p><p>此时再次请求的时候 parameter 就需要调整为 meida_type，否则就会以默认的方式去解析返回的文本信息</p><h2 id="Accept解析"><a href="#Accept解析" class="headerlink" title="Accept解析"></a>Accept解析</h2><p>这种就是默认的一种解析方式，无需进行任何配置，Spring 就是默认以这种模式进行解析的<br>GET请求<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/talkaboutHttpMeesageConvert/get_json.png" alt=""></p><p>XML请求<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/talkaboutHttpMeesageConvert/get_xml.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文只是简单的介绍了如何使用，后续会介绍原理篇</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- 
提纲：
一旦匹配不到就会走默认逻辑，具体的处理逻辑是
之所以配置文件请求url为json1，也可以返回json，是因为没有指定默认的返回格式，但是spring的默认是 */*，而spring的 json 的 convert 恰好又可以解析这种格式，所以就会导致除非可以
      
    
    </summary>
    
      <category term="Springboot" scheme="https://somersames.github.io/categories/Springboot/"/>
    
    
      <category term="Springboot" scheme="https://somersames.github.io/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊 SpringBoot 中的一些被忽视的注解</title>
    <link href="https://somersames.github.io/2021/04/05/talk-about-springboot-anno/"/>
    <id>https://somersames.github.io/2021/04/05/talk-about-springboot-anno/</id>
    <published>2021-04-05T14:53:24.000Z</published>
    <updated>2021-04-16T14:59:00.742Z</updated>
    
    <content type="html"><![CDATA[<p>之前在老的项目中看到了一个比较有趣的现象</p><p>有一个需求是需要对返回的数据进行加解密的操作，部分老代码是直接硬编码在项目中，但是后来有人改了一版，称之为 1.0 版本</p><p>1.0 版本是通过切面配合注解进行处理，大致的处理流程是对返回的对象通过反射遍历字段，如果发现字段上有指定的注解，则进行加密操作，如果发现该字段是一个对象的话，则进行递归处理，直至结束</p><p>后来有一个需求是对返回的手机号、身份证信息只需要对中间的信息进行加密，两边不处理…其他的例如家庭地址、家庭成员全部加密为密文</p><p>拿到这个需求的时候，想改也挺简单，只需要增加一个新的注解，然后替换该切面扫描到的返回值进行替换注解就可以了</p><p>但是这样会导致切面里面的代码越来越臃肿，于是后来通过 <code>RestControllerAdvice</code> 进行了一个优化处理</p><p>今天就来聊一聊这两个被忽视的注解</p><h1 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a>@ControllerAdvice</h1><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/SpringBoot-Anno/ControllerAdvice.png" alt=""></p><p>通过上述的描述我们可以知道该注解是可以在多个 <code>Controller</code> 中共享一些操作，配合 <code>ExceptionHandler</code>、<code>InitBinder</code> 等，可以在请求数据进入 Controller 之前进行一个预处理，减少代码中的硬编码部分。</p><p>对于 <code>ExceptionHandler</code> 大家可能不会很陌生，一个通用的异常处理，如果项目不是纯 <code>dubbo</code> 对外提供接口的话，那么应该是会用到该注解的 </p><h2 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="ExceptionHandler"></a>ExceptionHandler</h2><p>这个注解可以定义一个全局的异常处理器，可以将指定的异常转换为约定的格式返回，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(&#123;BusinessException.class&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> JsonResponseResult <span class="title">handleRuntimeException</span><span class="params">(<span class="keyword">final</span> Exception re)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> JsonResponseResult.error(XXX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样，一旦 <code>Controller</code> 里面抛出了 BusinessException，于是返回自动就变成了这种自定义的 XXX</p><p>不用每一次都在 Controller 中手动捕获异常然后转换成 code，从业务的角度来说只需要区分各种异常，然后统一地方进行收口处理，尽最大的努力避免对业务代码的入侵</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">code:1-99：参数问题</span><br><span class="line">code:2-199：权限不足</span><br><span class="line">XXX</span><br></pre></td></tr></table></figure><h2 id="InitBinder"><a href="#InitBinder" class="headerlink" title="InitBinder"></a>InitBinder</h2><p>该注解可以在请求参数进入 Controller 之前进行预处理，但是这个不能作用于 @RequestBody（这个注解是通过RequestBodyAdvice来生效的，不是同一个流程），这样就可以做一些比较好玩的操作了</p><h3 id="优势一："><a href="#优势一：" class="headerlink" title="优势一："></a>优势一：</h3><p>例如一个请求的 url 是 <code>localhost:8081/controller/testAdvice?advice=1-2</code></p><p>在业务中如果要接收这个参数是需要将 <code>advice</code> 定义为 String，那么如果想直接用对象来接收，会直接抛出一个异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/testAdvice"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testAdvice</span><span class="params">(@RequestParam (name = <span class="string">"advice"</span>)</span>Advice advice)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> advice.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/SpringBoot-Anno/string_error.png" alt=""></p><p>如果非要用对象来接收，这个时候就可以通过 <code>InitBinder</code> 来实现了</p><blockquote><p>GlobalAdvice</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalAdvice</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Logger logger = LoggerFactory.getLogger(GlobalAdvice.class);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerProduct</span><span class="params">(WebDataBinder webDataBinder, String advice)</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">"origin:&#123;&#125;"</span>,advice);</span><br><span class="line">        webDataBinder.registerCustomEditor(Advice.class,<span class="keyword">new</span> ProductEditor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ProductEditor</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductEditor</span> <span class="keyword">extends</span> <span class="title">PropertyEditorSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(text))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] strings = text.split(<span class="string">"-"</span>);</span><br><span class="line">        Advice advice = <span class="keyword">new</span> Advice();</span><br><span class="line">        advice.setName(strings[<span class="number">0</span>]);</span><br><span class="line">        advice.setAge(Integer.parseInt(strings[<span class="number">1</span>]));</span><br><span class="line">        setValue(advice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时再次请求 <code>localhost:8081/controller/testAdvice?advice=1-2</code> 就会发现是正常展示了</p><h3 id="优势二"><a href="#优势二" class="headerlink" title="优势二"></a>优势二</h3><p>可以解析前端 form-data 提交过来信息，在对象处理之前进行格式化，避免出错<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/testAdvice2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testAdvice2</span><span class="params">(Advice advice)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> advice.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isEmpty(text))&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 格式化，这里为了简单，直接new Date()</span></span><br><span class="line">    setValue(<span class="keyword">new</span> Date());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时 Date 就会在这里统一格式化，十分的方便</p><h3 id="优势三"><a href="#优势三" class="headerlink" title="优势三"></a>优势三</h3><p>配合 Validator 来使用</p><p>通过实现 <code>Validator</code> 这个类来实现一些复杂的检验规则，例如要求年龄大于1岁的，必须要有姓名，在这个场景下普通的校验规则就无法满足的，所以这个时候可以自定一个规则<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Logger logger = LoggerFactory.getLogger(GlobalAdvice.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerProduct</span><span class="params">(WebDataBinder webDataBinder, String advice)</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">"origin:&#123;&#125;"</span>,advice);</span><br><span class="line">        webDataBinder.registerCustomEditor(Advice.class,<span class="keyword">new</span> ProductEditor());</span><br><span class="line">        webDataBinder.registerCustomEditor(Date.class,<span class="keyword">new</span> DateEditor());</span><br><span class="line">        webDataBinder.setValidator(<span class="keyword">new</span> AdviceValidator());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdviceValidator</span> <span class="keyword">implements</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Advice.class.equals(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object target, Errors errors)</span> </span>&#123;</span><br><span class="line">        Advice advice = (Advice) target;</span><br><span class="line">        <span class="keyword">if</span>(advice.getAge() &gt;= <span class="number">1</span> &amp;&amp; StringUtils.isEmpty(advice.getName()))&#123;</span><br><span class="line">            errors.rejectValue(<span class="string">"name"</span>,<span class="string">"advice.name"</span>,<span class="string">"年龄大于1岁的，姓名不能为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时该注解也无需在实体类上面进行任何操作，很方便的进行扩展，通过配置中心，可以实现定制化的控制规则，方便运营及时的调整规则，实时生效</p><h1 id="RestControllerAdvice"><a href="#RestControllerAdvice" class="headerlink" title="@RestControllerAdvice"></a>@RestControllerAdvice</h1><p>官网的介绍如下：</p><blockquote><p>convenience annotation that is itself annotated with @ControllerAdvice and @ResponseBody</p></blockquote><p>表示这个注解包含了上面的 <code>ControllerAdvice</code> 以及 <code>ResponseBody</code>，</p><p>作用是可以对入参的 <code>@RequestBody</code>  和 <code>@ResponseBody</code> 进行处理，常见的如对返回数据加密等操作</p><p>例如刚才的 <code>Advice</code> 类，如果需要对其的 name 统计进行小写转大写（这里只是做展示，实际情况可能是对name进行加密操作），如果在业务代码中进行处理，那么会造成一种硬编码，</p><h2 id="ResponseBodyAdvice"><a href="#ResponseBodyAdvice" class="headerlink" title="ResponseBodyAdvice"></a>ResponseBodyAdvice</h2><blockquote><p>Allows customizing the response after the execution of an @ResponseBody or a esponseEntity controller method but before the body is written with an HttpMessageConverter</p></blockquote><p> 也就是说可以在 <code>HttpMessageConverter</code> 调用之前，对返回的对象进行处理，而 <code>HttpMessageConverter</code> 由于不在本文范畴，暂时忽略，但是需要记住这个类是将返回的对象处理成 json 的地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> somersames</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.PARAMETER,ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DecryptInfo &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代表解密的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> "idCard"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecryptAdvice</span> <span class="keyword">implements</span> <span class="title">ResponseBodyAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(MethodParameter returnType, Class converterType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> returnType.hasMethodAnnotation(DecryptInfo.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">beforeBodyWrite</span><span class="params">(Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType, ServerHttpRequest request, ServerHttpResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(body <span class="keyword">instanceof</span> Advice)&#123;</span><br><span class="line">            Advice advice = (Advice) body;</span><br><span class="line">            advice.setName(advice.getName().toUpperCase());</span><br><span class="line">            <span class="keyword">return</span> advice;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当定义好上述两个类以后，则只需要在方法上加上该注解即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/advice/decrypt"</span>)</span><br><span class="line"><span class="meta">@DecryptInfo</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Advice <span class="title">testAdvice</span><span class="params">(@Validated @RequestBody Advice bodyAdvice)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bodyAdvice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时 name 就会被转为大写，如果需要对入参进行处理，实现 <code>RequestBodyAdvice</code> 即可，相同的道理</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>在业务代码中，如果需要对 controller 层返回的数据进行加解密操作，有两种选择，一种是切面配合反射来遍历对象的字段判断是否包含指定的注解，如果含有的话，则直接进行加解密操作</p><p>还有一种就是今天的 <code>RestControllerAdvice</code> 扫描指定的包然后进行操作</p><p>如果是通过切面来进行处理，那么每一个返回的对象都必须明确的指明加解密的类型以及字段，需要配合注解使用，但是如果用 <code>RestControllerAdvice</code> 是否会是一个更好的选择呢？</p><p>显然，这两种方式个人认为切面比较不优雅，主要无法解耦，当需要扩展一个注解的功能时，会修改切面里面的代码，而且如果需要对返回的数据进行按照顺序处理，如果使用 <code>RestControllerAdvice</code>，那么直接使用 <code>@Order</code> 注解使用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前在老的项目中看到了一个比较有趣的现象&lt;/p&gt;
&lt;p&gt;有一个需求是需要对返回的数据进行加解密的操作，部分老代码是直接硬编码在项目中，但是后来有人改了一版，称之为 1.0 版本&lt;/p&gt;
&lt;p&gt;1.0 版本是通过切面配合注解进行处理，大致的处理流程是对返回的对象通过反射遍历字
      
    
    </summary>
    
      <category term="Springboot" scheme="https://somersames.github.io/categories/Springboot/"/>
    
    
      <category term="Springboot" scheme="https://somersames.github.io/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>夏令时的一些事</title>
    <link href="https://somersames.github.io/2020/08/24/%E5%A4%8F%E4%BB%A4%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/"/>
    <id>https://somersames.github.io/2020/08/24/夏令时的一些事/</id>
    <published>2020-08-24T15:26:39.000Z</published>
    <updated>2021-04-05T14:52:36.644Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redis实现的分布式锁是完美的吗？</title>
    <link href="https://somersames.github.io/2020/08/03/Redis%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%98%AF%E5%AE%8C%E7%BE%8E%E7%9A%84%E5%90%97%EF%BC%9F/"/>
    <id>https://somersames.github.io/2020/08/03/Redis实现的分布式锁是完美的吗？/</id>
    <published>2020-08-02T16:34:23.000Z</published>
    <updated>2021-04-05T14:52:36.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单实例"><a href="#单实例" class="headerlink" title="单实例"></a>单实例</h1><p><code>setnx</code> 是 <code>Redis</code> 官方提供的一个分布式原子性锁，它的实现利用了 <code>Redis</code> 在执行命令的时候是一个原子性操作，所以可以实现同一时间只有任务才能获取到锁。</p><p>当在同一个 <code>redis</code> 实例中进行加锁的操作的时候，如果加锁成功则会返回<code>1</code>，如果加锁失败的话，则是直接返回 <code>0</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setnx 'redislock' 1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>如果此时另一个任务想进行加锁的话，则会返回<code>0</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setnx 'redislock' 1</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p>虽然这样设置就可以实现一个分布式锁，但是如果一个客户端进行了加锁操作，后续自己的系统异常导致进程挂掉了，此时就会导致没有任务来进行解锁，从而导致任意一个客户端都无法再次加锁。</p><h2 id="超时时间"><a href="#超时时间" class="headerlink" title="超时时间"></a>超时时间</h2><p>redis官方提供了一个命令来支持这个加锁和设置超时时间的原子性命令：</p><blockquote><p><code>SET key value [EX seconds] [PX milliseconds] [NX|XX]</code></p></blockquote><p>其中 <code>NX</code> 和 <code>XX</code> 的区别在于，<code>NX</code> 是只有当 <code>key</code> 不存在的时候才设置，而 <code>XX</code> 则是当 <code>key</code> 存在的时候才进行设置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k1 v1 EX 10 NX</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>这个命令表示当 <code>k1</code> 不存在的时候，设置该 <code>key</code> ，并且将其超时时间设置为 <code>10s</code>。</p><p>这个时间是一般是由业务人员根据业务的特性来指定的，当加入了超时时间以后，如果该 <code>key</code> 在超时时间内没有被主动的调用 <code>del</code> 命令，等超时时间过了以后，该 <code>key</code> 会自动被删除。此时另外一个系统就可以对这个 <code>key</code> 加锁了。</p><p>这样设置以后虽然可以解决上面的锁无法释放的问题，但是却又有一个新的问题，就是锁被他人释放了，例如：</p><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/redission%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/setnx_2.png" alt=""></p><p>这种情况对于业务来说，是绝对不可以接受的，因为对于A任务来讲，它虽然释放了锁，但是它释放的其实是B的锁，此时如果有一个C任务再来加锁，就可以加锁成功了，于是分布式锁就变成了B、C可能在同一时间都在执行一个任务。</p><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>为了保证在只有自己加的锁才能被自己释放，此时每一个任务就需要自己的一个唯一标志，这个标志一定是要全局唯一的。当释放锁的时候，需要判断当前持有锁的ID是否是释放锁的任务ID，但是由于这是一个非原子性的操作，所以此时就需要通过 lua 脚本来执行。</p><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>在这里以 lua 脚本为例，lua脚本可以同时传入多个参数，在一个脚本里面执行，这样就可以判断加锁的value是不是当前传入的value。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k1 A EX 10 NX</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>此时的操作是 <code>A</code> 对 <code>k1</code> 进行加锁，假设 <code>A</code> 是一个全局唯一的，此时 <code>A</code> 对 <code>k1</code> 进行了加锁，并且锁的超时时间是 <code>10s</code> 。</p><h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><p>由于在这里是以 value 来作为唯一标志的，当释放锁的时候需要把当前的 <code>任务ID</code> 作为 <code>value</code> 传入，然后在删除key的时候，通过以下 lua 脚本来释放锁。</p><h4 id="lua脚本："><a href="#lua脚本：" class="headerlink" title="lua脚本："></a>lua脚本：</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">'exists'</span>,KEYS[<span class="number">1</span>]) == <span class="number">1</span>) <span class="keyword">and</span> (ARGV[<span class="number">1</span>] == redis.call(<span class="string">'get'</span>,KEYS[<span class="number">1</span>])) <span class="keyword">then</span> </span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">'del'</span>,KEYS[<span class="number">1</span>]) </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>首先加载 lua 脚本</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; script <span class="built_in">load</span> <span class="string">"if (redis.call('exists',KEYS[1]) == 1) and (ARGV[1] == redis.call('get',KEYS[1])) then return redis.call('del',KEYS[1]) else return 0 end;"</span></span><br><span class="line"><span class="string">"51fd717f3d833a79f1a102483df7932d4b71cd69"</span></span><br></pre></td></tr></table></figure><p>此时可以看到返回了一个hash值，这个值就是代表这个函数，当然也可以不用 hash 函数，每次用 eval 函数执行这个文本即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; eval "if (redis.call('exists',KEYS[1]) == 1) and (ARGV[1] == redis.call('get',KEYS[1])) then return redis.call('del',KEYS[1]) else return 0 end;" 1 k1 B</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p>此时可以看到以 B 尝试释放这个锁，但是返回的是0，并未释放成功，再次查看该锁：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">"A"</span><br></pre></td></tr></table></figure><p>可以看到 k1 还是被 A 锁持有，尝试以 A 来释放锁：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EVALSHA '51fd717f3d833a79f1a102483df7932d4b71cd69' 1 k1 A</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>可以看到已经被释放了，所以这个可以解决锁被其它任务释放的问题，但是还是无法解决超时导致的锁释放的问题。</p><h3 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h3><p>要解决这个问题，需要对超时时间进行续约，即除非 <code>A服务</code> 自己挂掉了让锁自己超时释放掉，否则就必须让A自己释放掉它。</p><h4 id="redission"><a href="#redission" class="headerlink" title="redission"></a>redission</h4><p><code>Redission</code> 是一款基于 Java 的 redis 操作 API 库，它采用的是一个 <code>Watch dog</code>  模式来解决这个问题的，具体做法是后台开启一个线程，这个线程每隔一定的时间去检查该锁还有多久超时，然后给这个锁进行续租。</p><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>上述 Redis 的分布式锁在单实例的情况下是可以完美运行的，但是一旦涉及到 <code>reids</code>集群，就会出现重复加锁的情况。假设在一个一主三从的redis架构中，</p><p>如果任务 A 对主节点进行加锁成功了，此时主节点突然挂掉了，但是在挂掉之前，其锁没有同步到从节点，此时从节点其中一个晋升为主节点，于是两个任务此时都加锁成功了。</p><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/redission%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/cluster-lock.png" alt=""></p><p>可以看到此时Redis 出现了脑裂情况，在这个情况下，A 和 B 都加锁成功了，但是这也就违背了分布式锁最初的初衷了，于是 RedLock 就被人提出来了。</p><h2 id="RedLock"><a href="#RedLock" class="headerlink" title="RedLock"></a>RedLock</h2><p>该算法是用 <code>Redis CRC16</code> 算法，计算出所有的 <code>master</code> 节点，然后记一个初始化时间，随后对所有的 <code>master</code> 节点进行加锁，计算出加锁的耗时时间，如果加锁的耗时时间小于超时时间，则接下来就可以执行任务了，否则锁过期了，就必须再次尝试再次加锁。</p><ol><li>记初始化时间</li><li>对所有的master加锁</li><li>计算加锁的耗时</li><li>判断是否小于过期时间</li><li>执行任务</li></ol><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>虽说 <code>RedLock</code> 可以解决某一个 <code>Redis</code> 节点挂掉，导致任务重复执行，但是还是无法避免如下问题：</p><ol><li><p>锁超时</p><p>例如如果在第4步的时候，应用出现了阻塞，就会导致锁其实过期了，但是任务 A 在锁过期以后还是在执行。</p></li><li><p>极度依赖服务器的时间</p><p>如果对A、B、C三个服务器进行加锁，任务 A 已经对A、B、C加锁了，但是此时B、C的服务器时间有问题，导致锁被提前释放了，而此时任务B对B、C加锁了，由于一半以上的master的节点已经加锁成功了，所以此时 任务B 其实也加锁成功了。</p></li></ol><p>​      </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于 Redis 的分布式锁，需要了解其可能出现的问题，然后再来做一些决策，任何一个技术都不是完美的，需要根据业务类型来选择最适合的。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" target="_blank" rel="noopener">http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单实例&quot;&gt;&lt;a href=&quot;#单实例&quot; class=&quot;headerlink&quot; title=&quot;单实例&quot;&gt;&lt;/a&gt;单实例&lt;/h1&gt;&lt;p&gt;&lt;code&gt;setnx&lt;/code&gt; 是 &lt;code&gt;Redis&lt;/code&gt; 官方提供的一个分布式原子性锁，它的实现利用了 &lt;co
      
    
    </summary>
    
      <category term="Redis" scheme="https://somersames.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://somersames.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>重温生产者和消费者模型</title>
    <link href="https://somersames.github.io/2020/07/26/%E9%87%8D%E6%B8%A9%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
    <id>https://somersames.github.io/2020/07/26/重温生产者和消费者模型/</id>
    <published>2020-07-26T15:01:54.000Z</published>
    <updated>2021-04-05T14:52:36.653Z</updated>
    
    <content type="html"><![CDATA[<p>生产者和消费者模型，主要解决的是数据的同步问题，生产者将数据放置一个存储区域，然后消费者过来取数据。这种模式类似于一个中间件，可以使得生产者不需要关心消费者什么时候来拿数据，同时在这种模式下，还可以控制两边的处理速率，避免数据的丢失。</p><p>下面以 Java 为例，来写一个生产者和消费者模型。</p><p>当队列满了的时候，生产者自己进行阻塞。而当消费者发现队列为空，则将自己阻塞。</p><p>所以要实现这个生产者消费者模型，首先必须有以下条件：</p><ol><li>生产者或者消费者必须支持可阻塞</li><li>在多线程的情况下，必须保证并发安全（即插入不能产生数据错误），取数据不可以重复取</li></ol><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>在<code>Java</code> 中，常用的阻塞队列有 <code>LinkedBlockingQueue</code> 或者 <code>ArrayBlockingQueue</code>，这两个阻塞队列的实现都是基于 <code>ReentrantLock</code> ，通过可重入锁来控制并发情况下的插入操作。</p><p>所以，如下便是在 Java 中的生产者和消费者模型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ThreadPoolExecutor product = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>,<span class="number">10</span>,<span class="number">1000</span>, TimeUnit.MICROSECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ThreadPoolExecutor consumer = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>,<span class="number">10</span>,<span class="number">1000</span>, TimeUnit.MICROSECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        LinkedBlockingQueue linkedBlockingQueue = <span class="keyword">new</span> LinkedBlockingQueue(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt; <span class="number">5</span> ;i++)&#123;</span><br><span class="line">            product.submit(<span class="keyword">new</span> Producer(<span class="number">100</span>,linkedBlockingQueue,i));</span><br><span class="line">            consumer.submit(<span class="keyword">new</span> Consumer(linkedBlockingQueue));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span>  <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    LinkedBlockingQueue linkedBlockingQueue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(LinkedBlockingQueue linkedBlockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.linkedBlockingQueue = linkedBlockingQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            consumerStart(linkedBlockingQueue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consumerStart</span><span class="params">(LinkedBlockingQueue&lt;Integer&gt; queue)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"消费者-----"</span>+queue.take());</span><br><span class="line">            Random random = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">            Thread.currentThread().sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> total;</span><br><span class="line">    LinkedBlockingQueue linkedBlockingQueue;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(<span class="keyword">int</span> total, LinkedBlockingQueue linkedBlockingQueue, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.total = total;</span><br><span class="line">        <span class="keyword">this</span>.linkedBlockingQueue = linkedBlockingQueue;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            productStart(linkedBlockingQueue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">productStart</span><span class="params">(LinkedBlockingQueue&lt;Integer&gt; queue)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(number + <span class="string">"生产者----"</span>+queue.size());</span><br><span class="line">            queue.put(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h2><p>如果考虑在 Java 中使用 <code>LinkedList</code> 来实现阻塞队列，那么第一点，需要实现入队和出队的原子性，因为 <code>LinkedList</code> 是基于双向链表来实现的，所以在这里必须保证其原子性的操作。</p><p>在<code>Java</code> 中如果要实现对于链表的原子性操作，首先是加锁，考虑到加锁和释放锁导致的性能开销，决定使用可重入锁</p><p>有两种锁，一个是 <code>synchronized</code>，一个则是 <code>ReentrantLock</code> </p><h3 id="锁的选型"><a href="#锁的选型" class="headerlink" title="锁的选型"></a>锁的选型</h3><p><code>synchronized</code> 的加锁逻辑依赖于 <code>JVM</code> ，同时也是支持可重入。并且<code>JDK1.6</code> 以后对其做了大量的优化，所以一般情况下可以直接用<code>synchronized</code>。</p><p> <code>ReentrantLock</code> 是 <code>Java</code> 语言自带的一种可重入锁，相较于  <code>synchronized</code> ，它含有公平锁和非公平锁两种模式，并且支持  <code>Condition</code>。</p><p>在这里由于<code>LinkedBlockingQueue</code>采用的 <code>ReentrantLock</code> ，所以在这里也是采用 <code>ReentrantLock</code> </p><h3 id="阻塞以及唤醒"><a href="#阻塞以及唤醒" class="headerlink" title="阻塞以及唤醒"></a>阻塞以及唤醒</h3><p>当没有数据的时候，需要消费者阻塞，同时队列已经满了的情况下，需要生产者进行阻塞，而配合这些操作的就是将这些线程阻塞，在<code>java</code> 中可以通过 <code>wait</code> 和 <code>notify</code> 方法来进行阻塞和唤醒，</p><p>如果使用的是 <code>ReentrantLock</code>，也可以使用自己的 <code>Condition</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonBlockModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Condition produceCondition = reentrantLock.newCondition();</span><br><span class="line">    <span class="keyword">static</span> Condition consumerCondition = reentrantLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ThreadPoolExecutor product = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>,<span class="number">10</span>,<span class="number">1000</span>, TimeUnit.MICROSECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ThreadPoolExecutor consumer = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>,<span class="number">10</span>,<span class="number">1000</span>, TimeUnit.MICROSECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> total =<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        LinkedList linkedList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt; <span class="number">5</span> ;i++)&#123;</span><br><span class="line">            product.submit(<span class="keyword">new</span> NonBlockProducer(reentrantLock,linkedList,i,produceCondition,consumerCondition));</span><br><span class="line">            consumer.submit(<span class="keyword">new</span> NonBlockConsumer(reentrantLock,linkedList,produceCondition,consumerCondition));</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.currentThread().sleep(<span class="number">1000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonBlockProducer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    ReentrantLock produceReentrantLock;</span><br><span class="line">    LinkedList&lt;Integer&gt; linkedList;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    Condition produceCondition;</span><br><span class="line">    Condition consumerCondition;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NonBlockProducer</span><span class="params">(ReentrantLock produceReentrantLock, LinkedList&lt;Integer&gt; linkedList, <span class="keyword">int</span> number, Condition produceCondition, Condition consumerCondition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.produceReentrantLock = produceReentrantLock;</span><br><span class="line">        <span class="keyword">this</span>.linkedList = linkedList;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        <span class="keyword">this</span>.produceCondition = produceCondition;</span><br><span class="line">        <span class="keyword">this</span>.consumerCondition = consumerCondition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            produceReentrantLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">10</span> == linkedList.size()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"队列已满，生产者被阻塞"</span> + number + <span class="string">"--"</span> + Thread.currentThread().getName());</span><br><span class="line">                    produceCondition.await();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(linkedList.size() +<span class="number">1</span> &lt; <span class="number">10</span>)&#123;</span><br><span class="line">                    linkedList.push(number);</span><br><span class="line">                    System.out.println(<span class="string">"添加元素"</span> + linkedList.size());</span><br><span class="line">                &#125;</span><br><span class="line">                consumerCondition.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                produceReentrantLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonBlockConsumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    ReentrantLock consumerReentrantLock;</span><br><span class="line">    LinkedList&lt;Integer&gt; linkedList;</span><br><span class="line">    Condition produceCondition;</span><br><span class="line">    Condition consumerCondition;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NonBlockConsumer</span><span class="params">(ReentrantLock consumerReentrantLock, LinkedList&lt;Integer&gt; linkedList, Condition produceCondition, Condition consumerCondition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.consumerReentrantLock = consumerReentrantLock;</span><br><span class="line">        <span class="keyword">this</span>.linkedList = linkedList;</span><br><span class="line">        <span class="keyword">this</span>.produceCondition = produceCondition;</span><br><span class="line">        <span class="keyword">this</span>.consumerCondition = consumerCondition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            consumerReentrantLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> == linkedList.size()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"队列已空，消费者已阻塞"</span> + Thread.currentThread().getName());</span><br><span class="line">                    consumerCondition.await();</span><br><span class="line">                &#125;</span><br><span class="line">                linkedList.pollLast();</span><br><span class="line">                System.out.println(<span class="string">"移除元素"</span> + linkedList.size());</span><br><span class="line">                <span class="keyword">if</span>(linkedList.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                    consumerCondition.signal();</span><br><span class="line">                &#125;</span><br><span class="line">                produceCondition.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                consumerReentrantLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;生产者和消费者模型，主要解决的是数据的同步问题，生产者将数据放置一个存储区域，然后消费者过来取数据。这种模式类似于一个中间件，可以使得生产者不需要关心消费者什么时候来拿数据，同时在这种模式下，还可以控制两边的处理速率，避免数据的丢失。&lt;/p&gt;
&lt;p&gt;下面以 Java 为例，
      
    
    </summary>
    
      <category term="并发" scheme="https://somersames.github.io/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://somersames.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>快速写一个程序将JVM的堆或者栈打满</title>
    <link href="https://somersames.github.io/2020/07/11/%E5%BF%AB%E9%80%9F%E5%86%99%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%B0%86JVM%E7%9A%84%E5%A0%86%E6%88%96%E8%80%85%E6%A0%88%E6%89%93%E6%BB%A1/"/>
    <id>https://somersames.github.io/2020/07/11/快速写一个程序将JVM的堆或者栈打满/</id>
    <published>2020-07-11T08:03:11.000Z</published>
    <updated>2021-04-05T14:52:36.647Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>首先「堆」或者「栈」在本质上其实是一个数据结构，简介如下：<br>「栈」既可以用链表来实现，又可以用数组来实现，用链表来实现的话，它是一个含有头指针和尾指针的一种数据结构，根据含有指针的不同，分为单链表和双向链表。<br>「堆」是一种类似于「完全二叉树」的数据结构</p><h2 id="JVM中的堆和栈"><a href="#JVM中的堆和栈" class="headerlink" title="JVM中的堆和栈"></a>JVM中的堆和栈</h2><p>在 JVM 中由于编译后的 class 文件都是一行行的指令，因此天然适合用「栈」这种数据结构，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>反编译后如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"JvmTest.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JvmTest</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iconst_0</span><br><span class="line">       <span class="number">1</span>: istore_1</span><br><span class="line">       <span class="number">2</span>: iinc          <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">       <span class="number">5</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">8</span>: iload_1</span><br><span class="line">       <span class="number">9</span>: invokevirtual #<span class="number">3</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">      <span class="number">12</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么对于这种指令来讲，以一种先进先出的方式存入肯定是最好的，所以在 JVM 中，栈的组成是一个一个的栈帧，那么每一个栈帧都包含如下几个部分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">局部变量表</span><br><span class="line">操作数栈</span><br><span class="line">动态链接</span><br><span class="line">方法出口</span><br></pre></td></tr></table></figure></p><p>以 <code>HotSpot VM</code> 为例，由于其采用了固定栈大小的实现，也就指定了每一个线程的所能分配的栈内存的大小，那么依据此思路，可以有如下两种方法造成栈溢出：</p><ol><li>无限递归，导致无法为该线程分配内存</li><li>无限创建线程，导致无法为该线程分配足够的内存</li></ol><blockquote><p><code>-Xss</code> 可以指定栈的大小</p></blockquote><h3 id="demo1"><a href="#demo1" class="headerlink" title="demo1:"></a>demo1:</h3><p>注意加上启动参数：<code>-Xss16m</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackOverFlowTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> StackOverFlowTest().over(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">over</span><span class="params">(<span class="keyword">int</span> deepth)</span></span>&#123;</span><br><span class="line">        System.out.println(deepth);</span><br><span class="line">        over(++deepth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不一会就可以看到 <code>java.lang.StackOverflowError</code></p><h3 id="demo2"><a href="#demo2" class="headerlink" title="demo2:"></a>demo2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackOverFlowTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> StackOverFlowTest().threadOver();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">threadOver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ThreadTest threadTest = <span class="keyword">new</span> ThreadTest(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(threadTest).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadTest</span><span class="params">(<span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.depth = depth;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> depth;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"thread start"</span> + depth);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>艹，运行到一半的时候，把 mac 搞挂了。<br>正常情况下是会出现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Unable to create <span class="keyword">new</span> <span class="keyword">native</span> thread</span><br></pre></td></tr></table></figure></p><h2 id="打满堆："><a href="#打满堆：" class="headerlink" title="打满堆："></a>打满堆：</h2><p>在 <code>JVM8</code> 中，堆一般存放的是 <code>对象实例</code>，含有 <code>S0</code>、<code>S1</code>、<code>Eden</code>、<code>Old</code>这几个区域，具体的可以查看 JVM 规范。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -Xmx32m</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;VM&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            VM vm = <span class="keyword">new</span> VM();</span><br><span class="line">            list.add(vm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VM</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[][] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>][<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行一段时间就会出现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at jvm.over_test.JvmTest$VM.&lt;init&gt;(JvmTest.java:<span class="number">30</span>)</span><br><span class="line">at jvm.over_test.JvmTest.main(JvmTest.java:<span class="number">24</span>)</span><br></pre></td></tr></table></figure></p><h2 id="元数据区："><a href="#元数据区：" class="headerlink" title="元数据区："></a>元数据区：</h2><p>首先 <code>元数据区</code> 保存的是 <strong>类信息、运行时常量池、以及即时编译器编译后的代码</strong> 等。那么根据存储的数据的特性，直接选择动态生成代理类的加载类信息来打满这个区域，需要注意的是这个区域使用的是机器的内存，所以在测试的时候最好指定下 <code>元数据区</code> 的大小。</p><blockquote><p>在这里也可以用自定的 <code>ClassLoader</code>，但是自定义 <code>ClassLoader</code> 需要重写 <code>loadClass</code> 方法，比较麻烦，所以直接选择使用代理类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -XX:MaxMetaspaceSize=16M -XX:MetaspaceSize=16M </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MalformedURLException</span>&#123;</span><br><span class="line">        List&lt;InterfaceA&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        String classFilePath = <span class="string">"file:/Users/sunzhaohui/Desktop/person/java/MyCsNote/jvm/src/main/java/jvm/StringTest"</span>;</span><br><span class="line">        URL[] classFileUrl = <span class="keyword">new</span> URL[]&#123;<span class="keyword">new</span> URL(classFilePath)&#125;;</span><br><span class="line">        URLClassLoader newClassLoader = <span class="keyword">new</span> URLClassLoader(classFileUrl);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            InterfaceA t = (InterfaceA) Proxy.newProxyInstance(newClassLoader, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;InterfaceA.class&#125;, <span class="keyword">new</span> MyInvocationHandler(<span class="keyword">new</span> InterfaceAImpl()));</span><br><span class="line">            list.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆和栈&quot;&gt;&lt;a href=&quot;#堆和栈&quot; class=&quot;headerlink&quot; title=&quot;堆和栈&quot;&gt;&lt;/a&gt;堆和栈&lt;/h1&gt;&lt;h2 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结
      
    
    </summary>
    
      <category term="JVM" scheme="https://somersames.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://somersames.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Thread.sleep(0)-vs-Thread.yield()</title>
    <link href="https://somersames.github.io/2020/07/07/Thread-sleep-0-vs-Thread-yield/"/>
    <id>https://somersames.github.io/2020/07/07/Thread-sleep-0-vs-Thread-yield/</id>
    <published>2020-07-06T16:25:44.000Z</published>
    <updated>2021-04-05T14:52:36.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Thread.sleep(long)</code> 和 <code>yield()</code> 都表示的是让出当前线程的 <code>CPU</code> 时间片，两者在执行的时候，都不会去释放自己已经持有的锁。</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>在现代的处理器中，以 <code>4核心CPU</code> 为例，这表示在同一个时刻，只会有 4 个线程在并行执行，而在每一个核心内部，多个线程其实是顺序执行的，它们的执行顺序依赖于线程的调度算法。</p><h3 id="线程调度算法"><a href="#线程调度算法" class="headerlink" title="线程调度算法"></a>线程调度算法</h3><p>目前主要的调度算法有如下几种「可能不全」：</p><ol><li>先进先出（FIFO）</li><li>最短耗时优先算法（SJF）</li><li>时间片轮转算法（RR）</li><li>优先级排序调度算法（PS）</li><li>多级反馈队列算法（MLFQ）</li></ol><p>以 <code>时间片轮转算法</code> 为例，多个线程每一个线程都会分到一定的执行时间，当本次执行时间结束以后，就会发生上下文切换。<br>同理，对于其他的调度算法，其实本质上都是一致的，就是在同一个时刻，一个核心只能执行一个线程，多线程其实就是通过CPU核心轮流执行线程。</p><p>在多线程编程中，如果需要暂停当前线程的执行，可以调用<code>Thread.sleep(long millis)</code> 方法，来让出<code>CPU</code> 时间片，即表示在接下来的 <code>millis</code> 毫秒内，该线程不再参与 <code>CPU</code> 时间片的竞争。</p><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>在 Java 中，可以通过执行 <code>jstack pid</code> 命令来查看线程的运行状态，如下图所示：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/ThreadSleep/ThreadStatus_1.png" alt=""><br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/ThreadSleep/ThreadStatus_2.png" alt=""></p><p>从上面两张图可以看到，目前在 Java 中，是已经含有四种状态了，那么还有两种没有列出来，它们分别是 <code>NEW</code>，<code>TERMINATED</code></p><ul><li><code>NEW</code>：这个状态表示的是线程刚刚创建，例如 <code>new Thread()</code>;</li><li><code>RUNNABLE</code>：其实这个状态，在 <code>Java</code> 中表示的是 <code>就绪</code> 和 <code>运行</code><ul><li><code>就绪</code> ：代表这个线程可以执行了，但是还在等待 <code>CPU</code> 的调度</li><li><code>运行</code> ：代表这个线程已经在执行中了</li></ul></li><li><code>WAITING</code>：表示该线程正在等待一些条件，常见于调用了<code>Object.wait</code>,<code>Thread.join</code>,<code>LockSupport.park</code></li><li><code>TIMED_WAITING</code>：对于线程的这种状态，常见于调用了 <code>Thread.sleep(long)</code> 或者 <code>Object.wait(long)</code> 方法等</li><li><code>BLOCKED</code>：常见于互斥锁的竞争</li><li><code>TERMINATED</code>：线程终止</li></ul><h2 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep"></a>Sleep</h2><p>那么当一个线程调用了 <code>Sleep</code> 方法之后，会由 <code>RUNNABLE</code> 转为 <code>TIMED_WAITING</code>，这个表示在接下来的 <code>long</code> 毫秒内，该线程不再参与 <code>CPU</code> 资源的竞争，需要注意的是 <code>sleep</code> 方法不会释放所持有的锁。</p><h3 id="Sleep-0"><a href="#Sleep-0" class="headerlink" title="Sleep(0)"></a>Sleep(0)</h3><p>那么当调用 <code>Sleep(0)</code> 的时候，究竟会发生什么，查看下 <code>Java</code> 的源代码，发现是一个 <code>native</code> 方法，于是查看 <code>hotspot</code> 方法，其代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_Sleep(JNIEnv* env, jclass threadClass, jlong millis))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_Sleep"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), <span class="string">"timeout value is negative"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Thread::is_interrupted (THREAD, <span class="literal">true</span>) &amp;&amp; !HAS_PENDING_EXCEPTION) &#123;</span><br><span class="line">    THROW_MSG(vmSymbols::java_lang_InterruptedException(), <span class="string">"sleep interrupted"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save current thread state and restore it at the end of this block.</span></span><br><span class="line">  <span class="comment">// And set new thread state to SLEEPING.</span></span><br><span class="line">  <span class="function">JavaThreadSleepState <span class="title">jtss</span><span class="params">(thread)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> USDT2</span></span><br><span class="line">  HS_DTRACE_PROBE1(hotspot, thread__sleep__begin, millis);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">  HOTSPOT_THREAD_SLEEP_BEGIN(</span><br><span class="line">                             millis);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line"></span><br><span class="line">  EventThreadSleep event;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// When ConvertSleepToYield is on, this matches the classic VM implementation of</span></span><br><span class="line">    <span class="comment">// JVM_Sleep. Critical for similar threading behaviour (Win32)</span></span><br><span class="line">    <span class="comment">// It appears that in certain GUI contexts, it may be beneficial to do a short sleep</span></span><br><span class="line">    <span class="comment">// for SOLARIS</span></span><br><span class="line">    <span class="keyword">if</span> (ConvertSleepToYield) &#123;</span><br><span class="line">      os::yield();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ThreadState old_state = thread-&gt;osthread()-&gt;get_state();</span><br><span class="line">      thread-&gt;osthread()-&gt;set_state(SLEEPING);</span><br><span class="line">      os::sleep(thread, MinSleepInterval, <span class="literal">false</span>);</span><br><span class="line">      thread-&gt;osthread()-&gt;set_state(old_state);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 忽略其他代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> USDT2</span></span><br><span class="line">  HS_DTRACE_PROBE1(hotspot, thread__sleep__end,<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">  HOTSPOT_THREAD_SLEEP_END(</span><br><span class="line">                           <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure></p><p>从这段代码可以看到，在 <code>JVM</code> 中有一个选项，叫做 <code>ConvertSleepToYield</code>，这个参数默认是为 <code>true</code> 的，所以当调用 <code>Sleep(0)</code> 的时候，默认的会调用 <code>Thread.yield()</code> 方法。</p><p>那么如果关闭了这个选项的话，会调用 <code>os::sleep(thread, MinSleepInterval, false);</code> ,而 <code>MinSleepInterval</code> 的值是 <code>1</code>，所以如果关闭了这个选项的话，那么 JVM 首先会将当前的线程状态赋值为 <code>old_state</code>，然后通过 <code>os::sleep</code> 让其休眠 <code>1ms</code>，然后在将线程设置成原来的状态。</p><h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>其实对于 <code>yield</code> 方法，jvm 也可以将其转换为 Sleep 方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_Yield(JNIEnv *env, jclass threadClass))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_Yield"</span>);</span><br><span class="line">  <span class="keyword">if</span> (os::dont_yield()) <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> USDT2</span></span><br><span class="line">  HS_DTRACE_PROBE0(hotspot, thread__yield);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">  HOTSPOT_THREAD_YIELD();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">  <span class="comment">// When ConvertYieldToSleep is off (default), this matches the classic VM use of yield.</span></span><br><span class="line">  <span class="comment">// Critical for similar threading behaviour</span></span><br><span class="line">  <span class="keyword">if</span> (ConvertYieldToSleep) &#123;</span><br><span class="line">    os::sleep(thread, MinSleepInterval, <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    os::yield();</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure></p><p>在 JVM 中，<code>ConvertYieldToSleep</code> 默认值是 <code>false</code>，所以如果不更改 JVM 的默认配置的话，<code>yield</code> 方法会调用 <code>os::yield();</code> 方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实对于 <code>Thread.sleep(0)</code> 和 <code>yield</code> 方法来讲，如果仅仅使用的是默认配置的话，那么它们最终调用的都是 <code>OS</code> 的 <code>yield</code> 方法。</p><p>那么其实对于它们来说，在执行的时候，都是让 <code>CPU</code> 再次发一个调度，如果当前的线程，没有被选中执行，那么它的状态就会由 <code>RUNNABLE</code> 变成 <code>WAITING</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Thread.sleep(long)&lt;/code&gt; 和 &lt;code&gt;yield()&lt;/code&gt; 都表示的是让出当前线程的 &lt;c
      
    
    </summary>
    
      <category term="Java" scheme="https://somersames.github.io/categories/Java/"/>
    
    
      <category term="java" scheme="https://somersames.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocalMap 简单分析</title>
    <link href="https://somersames.github.io/2020/07/02/ThreadLocalMap-simple-analysis/"/>
    <id>https://somersames.github.io/2020/07/02/ThreadLocalMap-simple-analysis/</id>
    <published>2020-07-01T16:05:58.000Z</published>
    <updated>2021-04-05T14:52:36.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>在使用多线程的时候，如果需要保存一份线程自己私有的一部分变量，避免其他线程污染这个变量的话，一般都会自己手动 new 一个 ThreadLocal，如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">threadLocal.set(<span class="string">"test"</span>);</span><br></pre></td></tr></table></figure></p><p>当需要在某一刻使用这个变量的时候，只需要手动调用下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.get();</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">## ThreadLocalMap</span><br><span class="line">ThreadLocalMap 是 ThreadLocal 的一个静态内部类，每一个线程在创建的时候都会有这个 ThreadLocalMap 变量，它的作用就是存储每一个通过 `threadLocal.set()` 方法存入的值，本质上也是一个HashMap。</span><br><span class="line"></span><br><span class="line">先看下它的一个内部类：</span><br><span class="line">### Entry</span><br><span class="line">不同于 WeakHashMap 是继承自 HashMap 的Entry，ThreadLocalMap 的Entry 则是自己的一个内部类。</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里可以看到的是，ThreadLocalMap.Entry 是以 <code>ThreadLocal&lt;?&gt;</code> 为 key 的，也就是 ThreadLocalMap 它的整体设计如下：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/ThreadLocalMap/ThreadLocalMap.png" alt=""></p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p><code>table</code>：表示的是一个 <code>Entry</code> 数组<br><code>threshold</code>：下一次扩容的临界值，算法为 数组的长度的 2/3<br><code>INITIAL_CAPACITY</code>：数组的大小，默认是 16</p><h4 id="Entry扩容"><a href="#Entry扩容" class="headerlink" title="Entry扩容"></a>Entry扩容</h4><p><code>table</code> 的扩容是直接新建了一个 <code>Entry[]</code> 数组，将其长度设置为旧数组长度的 2 倍，然后通过一个 <code>for</code> 循环，将元素都重新移至新的 <code>table</code> 上，但是在移植的过程中，如果发现了 <code>Entry</code> 中的 Key 为空的话，那么就会直接将其 value 设置为 null 来帮助GC，避免内存的泄漏。</p><blockquote><p>如果在移植的过程中发生了 Hash 碰撞，那么会直接将当前下标 + 1，然后判断该位置是否有元素，如果有的话，继续 + 1，直至没有元素。</p></blockquote><h3 id="新增过程"><a href="#新增过程" class="headerlink" title="新增过程"></a>新增过程</h3><p>当调用 <code>threadLocal.set()</code> 方法的时候，会首先判断 <code>ThreadLocalMap</code> 存不存在。从而进入不同的处理流程上来。</p><h4 id="ThreadLocalMap-不存在"><a href="#ThreadLocalMap-不存在" class="headerlink" title="ThreadLocalMap 不存在"></a>ThreadLocalMap 不存在</h4><p>如果不存在的话，就会调用 <code>createMap</code> 方法来进行初始化。<br>而 <code>createMap</code> 直接就是通过默认值来初始化一个 <code>ThreadLocalMap</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="ThreadLocalMap-存在"><a href="#ThreadLocalMap-存在" class="headerlink" title="ThreadLocalMap 存在"></a>ThreadLocalMap 存在</h4><p>如果存在的话，这时直接以当前的 <code>ThreadLocal</code> 为 <code>Key</code>，通过 <code>Hash算法</code> 算出该对象在 <code>table</code> 中的下标，然后判断该下标是否有值(Entry是否为null)，如果有值的话，则判断 <code>Entry</code> 中的 <code>key</code> 是否与当前的 <code>ThreadLocal</code> 相等（地址比较），如果相等的话，则直接将 <code>value</code> 赋值，然后 return。</p><p>如果 <code>Entry</code> 中的 <code>key</code> 为 <code>null</code> 的话，则会执行 <code>replaceStaleEntry</code> 方法来找 <code>key</code>，同时在这个方法内部，还会通过 <code>渐进式或者启发式</code> 的方式来进行清除旧key操作。<br>先大致列出其 set 的过程：</p><p><strong>1.</strong> 获取该 key 的 <code>threadLocalHashCode</code>，然后与当前 <code>table(Entry[]的长度) -1</code> 进行 <code>&amp;</code> 运算，计算出下标。</p><h5 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h5><p><code>ThreadLocalMap</code> 的 <code>Hash算法</code> 采用的是 <code>斐波那契散列</code>，其过程是用 <code>0x61c88647</code> 累加，然后用累加的结果与当前 <code>table(Entry[]的长度) - 1</code> 进行 <code>&amp;</code> 运算。</p><blockquote><p><code>0x61c88647</code> 转化为十进制是 <code>1640531527</code>，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>在这里的 <code>nextHashCode</code> 是一个 <code>AtomicInteger</code>，因此可以保证其原子性，而且又是私有的静态变量，所以可以尽量保证每一个 <code>ThreadLocal</code> 都会得到一个唯一的 <code>HashCode</code>。</p><p><strong>2.</strong> 找出 <code>table[i]</code> 中不为 <code>null</code> 的 <code>Entry</code>，在这个过程中会一直 <code>i+1</code>，如果 <code>i+1</code> 大于数组的最大下标的话，则直接从 0 开始寻找。</p><p><strong>3.</strong> 当在遍历的过程中，如果发现 <code>Entry 的 key</code> 与当前的 <code>ThreadLocal</code> 对象相等的话，则直接将值替换，如果发现某一个 <code>Entry</code> 的 <code>key</code> 为 null 的话，则直接进行 <code>replaceStaleEntry</code>。然后return。</p><h5 id="replaceStaleEntry方法"><a href="#replaceStaleEntry方法" class="headerlink" title="replaceStaleEntry方法"></a>replaceStaleEntry方法</h5><p>该方法出现在 <code>set方法</code> 的第三步，即当判断到 <code>Entry</code> 中的 key 为 <code>null</code>，那么此时就会调用 <code>replaceStaleEntry</code> 来清除那些被回收了的 <code>Key</code>。在这个方法里面，每一个遍历都会将 <code>staleSlot</code> 赋值到 <code>i</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先将 `staleSlot` 赋值为 `i` ，通过 `i` 向前遍历，直至遍历到第一个 `Entry` 为 null，如果在遍历的过程中发现某些 `Entry` 的 `key` 为 null 的话，则将 i 赋值到 `slotToExpunge`。如果说遍历了完整的一圈没发现 key 为 null 的 Entry 的话，那么一定会在 `staleSlot` 这个地方停下来，因为进入这个方法的前提就是 `key == null`。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随后再沿着传入的 `index` 的向后进行遍历，如果此时在遍历的过程中出现了 `Hash冲突`，则直接 `value` 赋值到当前 `Entry` 的 `value` 中。同时判断在第一个遍历中的 `slotToExpunge` 是不是 `staleSlot`，如果是的话，则直接当前的 `index` 设置为`slotToExpunge`，然后调用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为在 set 方法的遍历中，肯定不会出现 k == key，所以此时可以判断下，如果有的话，则直接赋值，然后就可以return 了。</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"><span class="comment">//第一个循环中，没有出现 key 为null 的 Entry，则直接将 slotToExpunge 赋值为 i，</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line"><span class="comment">//expungeStaleEntry 方法会进行 rehash，直至往后遍历到第一个为 null 的 Entry停止，在此期间也会进行rehash，同时在此期间，如果遇到了 key 为 null 的 Entry，会将他们的 Entry 以及 value 都置为 null，便于 GC。</span></span><br><span class="line"><span class="comment">//cleanSomeSlots 方法会以 log2(len) 的循环次数进行清除旧的 Entry，如果发现 Key 为 null 的 Entry，就会再次调用expungeStaleEntry 方法继续清理旧Key</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//如果在遍历的途中，没发现 k == key，那么此时如果在向前的遍历中，也没有发现 Key 为 null 的，此时就会将slotToExpunge 设置为 i。</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"><span class="comment">//如果说之前发现 key 为null 的话，那么此时slotToExpunge 肯定就不会等于 staleSlot，于是触发清除旧Key的方法。</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>4.</strong> 在第三步的时候，直接找到了为 <code>null</code> 的<code>Entry</code>，则直接新建一个 <code>Entry</code> 然后赋值，<br><strong>5.</strong> 当上述步骤都处理完了以后，会通过 <code>cleanSomeSlots</code> 进行判断，如果有 <code>Entry</code> 的弱引用是否被回收了，则会进行 <code>rehash</code>，除非数组的长度已经达到了 <code>threshold</code> 并且未发现 <code>Entry</code> 的弱引用被回收了，才会进行 rehash。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"><span class="keyword">int</span> sz = ++size;</span><br><span class="line"><span class="comment">// 在这里需要注意的是只有没发生弱引用的清除才会进行Rehash，因为一旦出现了清除，则会在 expungeStaleEntry 做 rehash，所以此时就不必在做一次了。</span></span><br><span class="line"><span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    rehash();</span><br></pre></td></tr></table></figure></p><h3 id="set方法流程图"><a href="#set方法流程图" class="headerlink" title="set方法流程图"></a>set方法流程图</h3><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/ThreadLocalMap/set.png" alt=""></p><h4 id="expungeStaleEntry-int-staleSlot-方法"><a href="#expungeStaleEntry-int-staleSlot-方法" class="headerlink" title="expungeStaleEntry(int staleSlot)方法"></a>expungeStaleEntry(int staleSlot)方法</h4><p>该方法是 <code>ThreadLocal</code> 主要用于清除旧 Key，其代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"> <span class="comment">//当前的Entry的key是null，则直接将value和Entry一起全部设置为 null，帮助GC</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 重新Rehash，不过rehash的范围是 staleSlot 到下一个为 null 的 Entry</span></span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>在这里之所以是要进行重新 <code>hash</code>，是因为一旦出现某一个 <code>Key</code> 被回收以后，会导致后面的 <code>Key</code> 无法正确的 <code>hash</code> 到数组的正确下标下，从而导致每一次的 <code>get</code> 操作都会进行一次遍历，时间复杂度由 <code>O(1)</code> 直接退化为 <code>O(n)</code></p></blockquote><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/ThreadLocalMap/rehash.png" alt=""></p><h3 id="Get方法"><a href="#Get方法" class="headerlink" title="Get方法"></a>Get方法</h3><p><code>ThreadLocal</code> 的 <code>get</code> 方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里需要注意的一个方法是 <code>getEntry</code> ,如果在调用的时候，发生了 <code>Hash冲突</code>，那么该方法会调用<code>getEntryAfterMiss</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里可以发现，其实最终还是调用的 <code>expungeStaleEntry</code>，而该方法在之前已经说过了，所以 <code>ThreadLocal</code> 在 <code>get</code> 的时候，其实还会旧的 <code>key</code> 的清除。直至遍历到第一个 <code>e == null</code> 的对象，此时则表示该 <code>key</code> 不存在，于是直接返回 <code>null</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，<code>ThreadLocal</code> 在 <code>set</code> 的过程中，首先会进行 <code>Hash</code> 找出下标，如果该下标的 <code>Entry</code> 为 <code>null</code> 的话，则直接赋值，如果不为 <code>null</code> 的话，则会进行遍历，直至找出第一个不为 <code>null</code> 的 <code>Entry</code> 然后赋值。</p><p>如果在遍历的过程中，发现了某些  <code>Entry</code> 的 <code>Key</code> 为 <code>null</code> 的话，则代表可以通过清理旧的 <code>Entry</code> 来进行赋值操作，那么其过程是，首先获取到在遍历过程中 <code>Entry</code> 的 <code>Key</code> 为 <code>null</code> 的下标，记为 <code>staleSlot</code>，然后向前遍历，直至第一个 <code>Entry</code> 为 <code>null</code> 止，然后记录在遍历的过程中，最后一个 <code>Entry</code> 的 <code>Key</code> 为 <code>null</code> 的下标。<br>随后进行第二次的遍历，如果在往后的遍历过程中，出现了 <code>Entry</code> 的 <code>key</code> 与当前的 <code>key</code> 相等的话，则直接赋值。</p><p>然后判断如果在之前的第一个遍历中，所有的 <code>Entry</code> 的 <code>key</code> 都不为 <code>null</code> ，那么此时直接将当前下标赋值为 <code>旧Key</code> 清除的起点，随后先进行一个<code>渐进式清理expungeStaleEntry</code>，等这一步清理完毕以后，再进行一次<code>启发式清理cleanSomeSlots</code>，<code>cleanSomeSlots</code>会进行一次 <code>log2(n)</code> 次清理，以<code>渐进式清理expungeStaleEntry</code> 后的 <code>index</code> 为起点，在之后的 <code>log2(n)</code> 下标内，如果还是出现了 <code>key</code> 为 <code>null</code> 的 <code>Entry</code>，则还是会再进行 <code>渐进式清理expungeStaleEntry</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ThreadLocal&quot;&gt;&lt;a href=&quot;#ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal&quot;&gt;&lt;/a&gt;ThreadLocal&lt;/h2&gt;&lt;p&gt;在使用多线程的时候，如果需要保存一份线程自己私有的一部分变量，避免其
      
    
    </summary>
    
      <category term="Java" scheme="https://somersames.github.io/categories/Java/"/>
    
    
      <category term="java" scheme="https://somersames.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>mysql中count(*)和count(1)的区别</title>
    <link href="https://somersames.github.io/2020/06/05/the-difference-between-count-and-count-1/"/>
    <id>https://somersames.github.io/2020/06/05/the-difference-between-count-and-count-1/</id>
    <published>2020-06-04T16:01:47.000Z</published>
    <updated>2021-04-05T14:52:36.616Z</updated>
    
    <content type="html"><![CDATA[<p>在进行旧的项目 review 的时候，我发现绝大多数的统计SQL都是基于 <code>count(1)</code> 来进行的，只有一少部分是基于 <code>count(*)</code>，那么这两种写法到底有什么区别。</p><p>mysql中，常用的存储引擎有<code>myisam</code>和<code>innodb</code>，但是由于<code>myisam</code>只支持表级别锁，而且还不支持事物，所以在mysql的5.5版本之后就将默认的存储引擎调整为<code>innodb</code>。</p><p>&nbsp;<br>以下实验基于 <code>Mysql8.0.1</code> 来进行<br>&nbsp; </p><p>首先这里准备了一个表.<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/mysql-diff-count/full_columns.png" alt=""></p><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/mysql-diff-count/mysql-showtable.png" alt=""></p><p>在此之前先通过 <code>show table status</code> 查看表中的数据，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from t_book;</span><br><span class="line">+----------+</span><br><span class="line">| count(*) |</span><br><span class="line">+----------+</span><br><span class="line">|    54173 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可以看到此时查询出来的<code>ROWS</code>是<code>53935</code>，那么再查看下通过索引查询出来的数据行数有多少呢？ 可以看到<code>show index from t_book</code> 查询出来的数据如下：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/mysql-diff-count/show_index.png" alt=""></p><p>其中有大概 238 条数据的统计差异，这其实是因为Mysql的<code>show table status</code>查询出来的只是一个估计值。</p><h3 id="查看系统的show-table-status"><a href="#查看系统的show-table-status" class="headerlink" title="查看系统的show table status"></a>查看系统的<code>show table status</code></h3><p>在mysql的系统库中可以看到 <code>t_book</code> 表的相关信息，可以使用如下方式：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/mysql-diff-count/mysql_status.png" alt=""><br>其中的<code>n_rows</code>就是之前查询出来的值，但是这一个值是一个粗略估计的值。<br>而 <code>clustered_index_size</code> 和 <code>sum_of_other_index_sizes</code> 则分别表示的是聚簇索引和其它的索引所占有的页的数量</p><blockquote><p>回到之前的主题上来，那么下面就来看下 <code>count(*)和count(1)</code> 的区别：</p></blockquote><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>首先打开 Mysql 的 <code>warnings</code>，便于分析日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; warnings;</span><br><span class="line">Show warnings enabled.</span><br></pre></td></tr></table></figure></p><p>然后再分析下两个之前的差异：</p><h4 id="count"><a href="#count" class="headerlink" title="count(*)"></a>count(*)</h4><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/mysql-diff-count/count%2A.png" alt=""><br>可以看到此时 <code>count*</code> 走的是一个二级索引，但是在 Note 里面可以看到最后 <code>count(*)</code> 还是被转换成了<code>count(0)</code>。  </p><h4 id="count-1"><a href="#count-1" class="headerlink" title="count(1)"></a>count(1)</h4><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/mysql-diff-count/count1.png" alt=""><br>而 <code>count(1)</code> 可以发现也是走的一个二级索引</p><h3 id="索引的选择"><a href="#索引的选择" class="headerlink" title="索引的选择"></a>索引的选择</h3><p>在 <code>Mysql</code> 中，由于主键索引一般情况下是比二级索引大的，所以在Mysql中，如果有二级索引的话，那么Mysql一定会选择一个二级索引来作为 <code>count</code> 的字段。</p><p>但是当有多个二级索引的时候，Mysql又会如何选择索引呢？</p><p>首先以 <code>book_page</code> 为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create index book_page on t_book(book_page);</span><br><span class="line">Query OK, 0 rows affected (0.12 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure></p><p>然后通过 <code>count</code> 函数查询如下：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/mysql-diff-count/mysql_count_num.png" alt=""></p><blockquote><p>由于 count(1) 执行结果与这个类似，就不放截图了</p></blockquote><p>这个时候可以看到 <code>book_page</code> 的索引 <strong>key_len</strong> 是5，那么如果第二个 <code>二级索引</code> 的 key_len 比这个短的话，那么 Mysql 会该如何选择呢？ </p><h4 id="以-book-num-作为索引"><a href="#以-book-num-作为索引" class="headerlink" title="以 book_num 作为索引"></a>以 book_num 作为索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create index book_num on t_book(book_num);</span><br><span class="line">Query OK, 0 rows affected (0.12 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>此时查看 <code>count(*)</code>和 <code>count(1)</code>，可以发现 <code>Mysql</code> 选择的是 <code>book_num</code> 索引作为 count 的字段。</p><blockquote><p>对比之前的索引的 <code>key_len</code>，你会发现 <code>Mysql</code> 在有多个二级索引的情况下，是会优先选择 <code>key_len</code> 较小的索引。</p></blockquote><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/mysql-diff-count/mysql_key_len4.png" alt=""></p><p><strong>由于<code>count(*)</code>和 <code>count(1)</code>索引的选择是一样的，此时就不放 <code>count(1)</code> 截图</strong> </p><blockquote><p>PS：为了验证索引的创建顺序对 Mysql count 的选择没有影响，因此在这之后，又测试了一遍，不过是先创建的 <code>book_num</code>，后创建的 <code>book_page</code>，此时发现 Mysql 还是选择 <code>book_num</code> 作为索引。</p></blockquote><h4 id="相同的Key-len"><a href="#相同的Key-len" class="headerlink" title="相同的Key_len"></a>相同的Key_len</h4><p>&nbsp;<br>如果此时两个二级索引的 <code>key_len</code> 相同，<code>Mysql</code> 又会怎样选择呢？<br>此时修改 <code>book_num</code> ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE t_book MODIFY  book_num int(11) NULL;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.92 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 1</span><br></pre></td></tr></table></figure></p><p>此时进行 explain：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/mysql-diff-count/mysql_ken_len5.png" alt=""></p><p>再反复的测试之后，会发现 Mysql 在 <code>相同的 key_len</code> 下，会自动的选择最后一个创建的 <code>最小 key_len</code> 索引最为 count 索引。</p><h4 id="索引的选择跟区分度有关系吗"><a href="#索引的选择跟区分度有关系吗" class="headerlink" title="索引的选择跟区分度有关系吗"></a>索引的选择跟区分度有关系吗</h4><p> &nbsp;<br>将 <code>book_page</code> 的字段区分度弄的低一点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update t_book set book_page = 10 limit 10000;</span><br><span class="line">Query OK, 9888 rows affected (0.10 sec)</span><br><span class="line">Rows matched: 10000  Changed: 9888  Warnings: 0</span><br></pre></td></tr></table></figure></p><p> &nbsp;<br>然后此时再查看 <code>Mysql</code> 是如何选择索引的。<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/mysql-diff-count/book_page_index.png" alt=""></p><p>此时还是选择的是 <code>book_page</code> 字段，如果再把 <code>book_num</code> 的区分度弄的更低呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update t_book set book_num = 100 limit 30000;</span><br><span class="line">Query OK, 29970 rows affected (0.40 sec)</span><br><span class="line">Rows matched: 30000  Changed: 29970  Warnings: 0</span><br></pre></td></tr></table></figure></p><p>最后对比会发现，执行的还是 <code>book_page</code> 作为索引，那么这是为什么呢？</p><h3 id="optimizer-trace-分析"><a href="#optimizer-trace-分析" class="headerlink" title="optimizer_trace 分析"></a>optimizer_trace 分析</h3><p>首先打开<code>optimizer_trace</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET optimizer_trace=&quot;enabled=on&quot;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>然后执行 <code>count(1)</code> 语句。最后查看结果如下：只截取关键信息：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/mysql-diff-count/page_num_cost.png" alt=""></p><p>可以看到在使用 <code>book_page</code> 做索引的时候，Mysql认为其 cost 是 5808.1，那么对于 <code>book_num</code> 索引呢？</p><h3 id="book-num"><a href="#book-num" class="headerlink" title="book_num"></a>book_num</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from t_book force index(book_num);</span><br><span class="line">+----------+</span><br><span class="line">| count(*) |</span><br><span class="line">+----------+</span><br><span class="line">|    54173 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>执行完以后，查看 cost 如下：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/mysql-diff-count/book_num_cost.png" alt=""></p><p>可以看到他的 cost 是 59193，所以 <code>Mysql</code> 认为 <code>book_page</code> 更加划算，那么是不是因为 <code>book_num</code> 的区分度太低，导致 cost 变大了呢？，此时调整 <code>book_page</code> 字段的值，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update t_book set book_page =1 limit 53000;</span><br><span class="line">Query OK, 52548 rows affected (0.68 sec)</span><br><span class="line">Rows matched: 53000  Changed: 52548  Warnings: 0</span><br></pre></td></tr></table></figure></p><p>然后会发现，Mysql 还是会选择 <code>book_page</code> 作为索引来进行 count，于是后来测试了下创建索引的顺序，发现当 <code>key_len</code> 相同的时候，Mysql是会选择首次创建的索引来进行 <code>count</code>，除非有更小的 <code>key_len</code>  出现。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以 <code>Mysql</code> 在选择 <code>count</code> 的时候，优先会选择 <code>二级索引</code>，当有多个 <code>二级索引</code> 的时候，会优先选择 <code>key_len</code> 小的，当有多个 <code>key_len</code> 相同的二级索引时，直接选择第一次创建该 <code>key_len</code> 的索引。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在进行旧的项目 review 的时候，我发现绝大多数的统计SQL都是基于 &lt;code&gt;count(1)&lt;/code&gt; 来进行的，只有一少部分是基于 &lt;code&gt;count(*)&lt;/code&gt;，那么这两种写法到底有什么区别。&lt;/p&gt;
&lt;p&gt;mysql中，常用的存储引擎有&lt;co
      
    
    </summary>
    
      <category term="Mysql" scheme="https://somersames.github.io/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="https://somersames.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Springboot自定义@EnableXX注解</title>
    <link href="https://somersames.github.io/2020/05/26/define-a-enable-anno-in-springboot/"/>
    <id>https://somersames.github.io/2020/05/26/define-a-enable-anno-in-springboot/</id>
    <published>2020-05-25T16:05:16.000Z</published>
    <updated>2021-04-05T14:52:36.592Z</updated>
    
    <content type="html"><![CDATA[<p>在SpringBoot中，经常可以看到许多以 <code>@Enable</code> 开头的注解，例如：<code>@EnableAutoConfiguration</code>，<code>@EnableAsync</code>……，那么我们是否可以自己定义一个注解呢？</p><p>其实自定义注解最终都是利用到了 <code>ImportBeanDefinitionRegistrar</code> 这个类，通过手动的方式，将一个类注册成为 <code>Bean</code>，然后在进行一系列的操作，下面就来看下 <code>ImportBeanDefinitionRegistrar</code></p><h2 id="ImportBeanDefinitionRegistrar"><a href="#ImportBeanDefinitionRegistrar" class="headerlink" title="ImportBeanDefinitionRegistrar"></a>ImportBeanDefinitionRegistrar</h2><p>这个类的代码如下：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/how%20to%20define%20a%20annotion/ImportBeanDefinitionRegistrar.png" alt=""></p><p>可以看到这个类的结构很简单，就是一个方法，那么下面来看下这两个参数是什么意思。</p><h3 id="AnnotationMetadata"><a href="#AnnotationMetadata" class="headerlink" title="AnnotationMetadata"></a>AnnotationMetadata</h3><p>从字面的意思上可以看出来是一个注解的元数据，它的里面的的方法如下：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/how%20to%20define%20a%20annotion/AnnotationMetadata.png" alt=""><br>都是一些获取注解信息的方法，那么第二个参数呢</p><h3 id="BeanDefinitionRegistry"><a href="#BeanDefinitionRegistry" class="headerlink" title="BeanDefinitionRegistry"></a>BeanDefinitionRegistry</h3><p>从字面的意思上可以看出来这个类是用于注册 <code>Bean</code> 的，其中最常见的就是 <code>registerBeanDefinition</code> 方法。它提供了两个参数 <code>String beanName, BeanDefinition beanDefinition</code>，而具体使用，则来看看demo。</p><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>假设现在有一个需求是要写一个切面，这个切面负责打印<code>controller</code> 的log。但是可能某些系统有自己的日志格式，不太需要这个切面AOP，所以希望可以增加一个开关，然后是按需引用。<br>下面就来开始写一个这样的demo，项目结构如下：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/how%20to%20define%20a%20annotion/project-tree.png" alt=""></p><p>在这里为什么会初始化两个文件夹，是因为 <code>@SpringBootApplication</code> 这个注解会默认将当前目录以及它的下级目录下的 <code>Bean</code> 注入到容器中，所以新建一个同级目录<code>anno</code> 就是为了不让 <code>@SpringBootApplication</code> 加载切面。</p><p>然后启动 <code>Application</code> 这个类，其中 <code>RestControllerTest</code> 就是一个很简单的 <code>Controller</code>，如下：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/how%20to%20define%20a%20annotion/RestControllerTest.png" alt=""></p><p>然后请求<code>http://localhost:8081/api/query/1</code>，可以看到在控制台没有任何的输出，那就说明自定义的切面还没有生效，此时在 <code>Application</code> 上添加我们的自定义注解，添加后代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableLog</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时在此启动项目，你会发现已经已经在控制台有我们的日志log了。<br>实现的细节见下面几个类：</p><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><h3 id="interface"><a href="#interface" class="headerlink" title="@interface"></a>@interface</h3><p>首先，我们需要定义一个注解，其代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;LogRegister.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableLog &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里使用了 <code>@Import</code> 这个注解，由于不是本文的重点，因此不讲述其作用,（后面讲自动装配的原理时会讲解）然后这里有一个 <code>LogRegistrar</code> 类，这个类就是实现自定义注解的关键。</p><h3 id="LogRegister"><a href="#LogRegister" class="headerlink" title="LogRegister"></a>LogRegister</h3><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/how%20to%20define%20a%20annotion/LogRegister.png" alt=""></p><p>这个类的作用，就是让 <code>BeanDefinitionRegistry</code> 将我们的 <code>LogAop</code> 注册成一个Bean，只有当注册成一个 <code>Bean</code> 以后，该切面才会生效。</p><h3 id="LogAop"><a href="#LogAop" class="headerlink" title="LogAop"></a>LogAop</h3><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/how%20to%20define%20a%20annotion/LogAop.png" alt=""></p><p>该类就是一个切面类，负责打印请求的耗时。自此，一个自定义注解就完成了，当第三方想接入该日志log的时候，就可以直接使用 <code>@EnableLog</code> 来开启。</p><blockquote><p>ps：注意调整<code>@Pointcut</code> 的切点，否则会切不到</p></blockquote><p>这就是最简单的自定义注解了，至于里面涉及到的原理，后续可能会写一些文章来补充。</p><p>如果需要查看源代码的话，可以访问如下 <code>github</code> 地址：</p><blockquote><p><a href="https://github.com/Somersames/spring-doc-sample/tree/master/anno-test" target="_blank" rel="noopener">https://github.com/Somersames/spring-doc-sample/tree/master/anno-test</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在SpringBoot中，经常可以看到许多以 &lt;code&gt;@Enable&lt;/code&gt; 开头的注解，例如：&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;，&lt;code&gt;@EnableAsync&lt;/code&gt;……，那么我们是否可以自己定义一个注解呢？
      
    
    </summary>
    
      <category term="Springboot" scheme="https://somersames.github.io/categories/Springboot/"/>
    
    
      <category term="Springboot" scheme="https://somersames.github.io/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>Springboot的maven间接依赖</title>
    <link href="https://somersames.github.io/2020/05/19/springboot-indirect-maven-rely/"/>
    <id>https://somersames.github.io/2020/05/19/springboot-indirect-maven-rely/</id>
    <published>2020-05-18T16:21:53.000Z</published>
    <updated>2021-04-05T14:52:36.608Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中经常使用 <code>maven</code> 来管理项目，但是有时候对于 <code>maven</code> 的细节还是了解的不是很清楚，因此今天复习下。</p><h2 id="maven项目"><a href="#maven项目" class="headerlink" title="maven项目"></a>maven项目</h2><p>首先开始建立一个最简单的 <code>maven</code> 项目，其配置如下图：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/maven-project/maven-project.png" alt=""></p><p>可以看到最上面一行是 <code>xml</code> 的文件描述符，然后再是 <code>project</code>，在这里引入 xsd 文件。</p><blockquote><p>XSD(XML Schemas Definition)XML Schema，描述了 xml 文档的结构，用于判断其是否符合 <code>xml</code> 的格式要求</p></blockquote><p>然后下面就是 <code>groupId</code>，通常是公司的域名，<code>artifactId</code> 通常指的是项目名称。</p><h2 id="Springboot项目"><a href="#Springboot项目" class="headerlink" title="Springboot项目"></a>Springboot项目</h2><p>按照官方的指导，在项目中首先引用 <code>spring-boot-starter-parent</code>，修改后的 <code>pom.xml</code> 如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>maven-test<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>当准备在启动类上加 <code>@SpringBootApplication</code> 注解的时候，此时 IDEA 会提示找不到这个注解。这是正常的，因为 <code>parent</code> 只是把这个项目的配置和依赖信息统一化了，使得 <code>子pom</code> 就不用关心版本问题，例如在项目中引入<code>spring-boot-starter-web</code>，当配置了 <code>parent</code> 之后，只需要在 <code>子pom</code> 中如下配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>那么它的配置信息就会自动的从 <code>parent</code> 中读取。例如刚刚的<code>spring-boot-starter-web</code>信息，它的版本信息如下：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/maven-project/maven-web-version.png" alt=""></p><blockquote><p>tips:使用命令<code>mvn -Dverbose dependency:tree</code>就可以像这样打印 jar 的依赖</p></blockquote><p>那么 springboot 又是怎样来自动识别版本号的呢，此时就就涉及到了<code>spring-boot-dependencies</code></p><h2 id="spring-boot-dependencies"><a href="#spring-boot-dependencies" class="headerlink" title="spring-boot-dependencies"></a>spring-boot-dependencies</h2><p><code>spring-boot-dependencies</code> 是 <code>spring-boot-starter-parent</code> 的一个 parent，可以在 <code>spring-boot-starter-parent</code> 的 <code>pom</code> 文件中看到。<br>打开 <code>spring-boot-dependencies</code> 文件，你会发现它里面几乎全部都是一些配置信息，而刚刚的<code>spring-boot-dependencies</code> 版本号就是来自于此。<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/maven-project/depence-maven.png" alt=""></p><p>到目前为止，可以基本理清 <code>springboot</code> 的依赖关系了。<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/maven-project/pom-relation.png" alt=""></p><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>在工程中，随便写一个 <code>controller</code>，然后执行<code>mvn package</code>，此时会在 <code>target</code> 目录下出现一个 jar 包，然后运行 jar 包，正常启动OK。</p><h2 id="替换parent"><a href="#替换parent" class="headerlink" title="替换parent"></a>替换parent</h2><p>既然 <code>spring-boot-starter-parent</code> 是依赖于 <code>spring-boot-dependencies</code>的，那么可不可以直接将<code>parent</code> 设置为<code>spring-boot-dependencies</code>呢，修改 pom 文件如下:<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/maven-project/replace-parent.png" alt=""></p><p>然后执行<code>mvn package</code>，执行的时候是成功的，但是当你用 <code>java -jar maven-test.jar</code> 的时候，你会发现提示如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target java -jar maven-test.jar</span><br><span class="line">maven-test.jar中没有主清单属性</span><br></pre></td></tr></table></figure></p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>首先分析下两个的 <code>maven</code> log。</p><h4 id="spring-boot-starter-parent作为parent"><a href="#spring-boot-starter-parent作为parent" class="headerlink" title="spring-boot-starter-parent作为parent"></a><strong>spring-boot-starter-parent作为parent</strong></h4><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/maven-project/parent-log.png" alt=""></p><h4 id="spring-boot-dependencies作为parent"><a href="#spring-boot-dependencies作为parent" class="headerlink" title="spring-boot-dependencies作为parent"></a><strong>spring-boot-dependencies作为parent</strong></h4><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/maven-project/depence-log.png" alt=""></p><p>可以看到第二次的打包插件是 <code>maven-jar-plugin</code>，也就是说 springboot 的项目一些资源并没有打包进来，查看 <code>spring-boot-maven-plugin</code> 插件，发现它是来自于 <code>spring-boot-starter-parent</code> 里面的，但是在文章的开头部分，是已经手动的将其引入到了 pom 文件，那么修改 parent 以后未执行的话，最有可能就是版本号的缺失导致的，于是修改pom：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.11.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">finalName</span>&gt;</span>maven-test<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后运行<code>mvn package</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[INFO] --- spring-boot-maven-plugin:<span class="number">2.1</span>.11.RELEASE:repackage (repackage) @ maven-test ---</span><br><span class="line">[INFO] Replacing main artifact with repackaged archive</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br></pre></td></tr></table></figure></p><p>你会发现此时打包出来的 jar 文件已经可以运行了。</p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>那么假设项目已经有了自己的 <code>parent</code>，如果还想用 <code>spring-boot-dependencies</code> 来进行统一的一个全局版本控制，那么有如下的解决办法</p><p>在自己的<code>parent</code>中设置parent为 <code>spring-boot-starter-parent</code>，那么根据 maven 的继承属性，所有的 <code>子pom</code> 也就顺带继承了 <code>spring-boot-starter-parent</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在项目中经常使用 &lt;code&gt;maven&lt;/code&gt; 来管理项目，但是有时候对于 &lt;code&gt;maven&lt;/code&gt; 的细节还是了解的不是很清楚，因此今天复习下。&lt;/p&gt;
&lt;h2 id=&quot;maven项目&quot;&gt;&lt;a href=&quot;#maven项目&quot; class=&quot;header
      
    
    </summary>
    
      <category term="Springboot" scheme="https://somersames.github.io/categories/Springboot/"/>
    
    
      <category term="maven" scheme="https://somersames.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>阿里云SDK使用代理的一个坑</title>
    <link href="https://somersames.github.io/2020/05/16/%E9%98%BF%E9%87%8C%E4%BA%91SDK%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91/"/>
    <id>https://somersames.github.io/2020/05/16/阿里云SDK使用代理的一个坑/</id>
    <published>2020-05-16T13:25:49.000Z</published>
    <updated>2021-04-05T14:52:36.653Z</updated>
    
    <content type="html"><![CDATA[<p>由于项目中需要使用阿里云的短信平台，所以直接引用了最新的SDK，版本号为 <code>4.5.1</code>。但是由于机器在内网环境，如果需要访问外部网络的话，需要代理机器。于是去看下 阿里的SDK 官方文档，如何支持代理访问，于是找到以下内容：</p><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/%E9%98%BF%E9%87%8CSDK%E7%9A%84%E5%9D%91/%E9%98%BF%E9%87%8CSDK%E4%BB%A3%E7%90%86.png" alt=""></p><p>坑就坑在这个文档里面的设置方法，设置了并没有什么用。于是自己研究了下这种设置为什么不生效。</p><h2 id="System-setProperty"><a href="#System-setProperty" class="headerlink" title="System.setProperty"></a>System.setProperty</h2><p>这个命令和在启动参数中加 <code>-DXXX=XXX</code> 是一样的效果，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">"http.proxyHost"</span>, <span class="string">"127.0.0.1"</span>); </span><br><span class="line">System.setProperty(<span class="string">"http.proxyPort"</span>, <span class="string">"8888"</span>);</span><br></pre></td></tr></table></figure></p><p>就等价于 <code>-Dhttp.proxyHost=127.0.0.1 -Dhttp.proxyPort = 8888</code>，但是这种设置有一个限制，那就是只对 JDK 自带的 <code>HttpURLConnection</code> 有效，如下Demo：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/%E9%98%BF%E9%87%8CSDK%E7%9A%84%E5%9D%91/JDK%E7%9A%84Http%E4%BB%A3%E7%90%86.png" alt=""></p><p>当我们执行这段代码的时候，你会发现确实走了代理（可以本地随便设置一个IP加端口，你会发现一直卡在那里），那么既然这是有效的，就说明了阿里云的 Http 请求一定不是通过 JDK 的 <code>HttpURLConnection</code> 发送的。</p><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>在阿里 <code>doCommonResponse</code> 的调用链路中，发现有一处代码 <code>com.aliyuncs.DefaultAcsClient#doRealAction</code> 如下：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/%E9%98%BF%E9%87%8CSDK%E7%9A%84%E5%9D%91/ali-http-proxy.png" alt=""></p><p>此时阿里的SDK会通过 <code>System.getenv(&quot;HTTPS_PROXY&quot;)</code> 和 <code>System.getenv(&quot;HTTP_PROXY&quot;)</code> 来判断系统的环境中是否有如下两个变量。有的话就设置到 <code>HttpClientConfig</code> 中，没有的话则直接  return，既然我们系统环境里面没有这两个字段，那么肯定不会设置代理，于是继续往下跟代码。</p><p>最终发送 Http 请求的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> IHttpClient httpClient;</span><br><span class="line">...省略相关代码</span><br><span class="line"><span class="comment">// com.aliyuncs.DefaultAcsClient#doRealAction 第330行</span></span><br><span class="line">response = <span class="keyword">this</span>.httpClient.syncInvoke(httpRequest);</span><br></pre></td></tr></table></figure></p><p><code>httpClient</code> 最终对应的是 <code>IHttpClient</code>，它是阿里 SDK 里面的一个类。</p><h3 id="IHttpClient"><a href="#IHttpClient" class="headerlink" title="IHttpClient"></a>IHttpClient</h3><p>首先看下它的结构。<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/%E9%98%BF%E9%87%8CSDK%E7%9A%84%E5%9D%91/ali-class-struct.png" alt=""></p><p>在这边有两个实现类，<code>ApacheHttpClient</code> 是 apache 下面的一个包，而 <code>CompatibleUrlConnClient</code> 则是 JDK 自带的 http 请求类，那么阿里的SDK到底是初始化那一个SDK呢？</p><p>首先查看官方的发送短信Demo：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">... 省略相关代码</span><br><span class="line">IClientProfile profile = DefaultProfile.getProfile(<span class="string">"cn-hangzhou"</span>, accessKeyId,</span><br><span class="line">accessKeySecret);</span><br><span class="line">IAcsClient acsClient = <span class="keyword">new</span> DefaultAcsClient(profile);</span><br></pre></td></tr></table></figure></p><p><code>new DefaultAcsClient(profile)</code> 这行代码最终会调用<br><code>com.aliyuncs.DefaultAcsClient#DefaultAcsClient(com.aliyuncs.profile.IClientProfile, com.aliyuncs.auth.AlibabaCloudCredentialsProvider)</code> 这个构造器。</p><p>而且在这一行代码里面会进行 <code>HttpClientConfig</code> 的初始化，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultAcsClient</span><span class="params">(IClientProfile profile, AlibabaCloudCredentialsProvider credentialsProvider)</span> </span>&#123;</span><br><span class="line">... 省略相关代码</span><br><span class="line">    <span class="keyword">this</span>.httpClient = HttpClientFactory.buildClient(<span class="keyword">this</span>.clientProfile);</span><br><span class="line">... 省略相关代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/%E9%98%BF%E9%87%8CSDK%E7%9A%84%E5%9D%91/default-config.png" alt=""></p><p> 而在 <code>HttpClientConfig.getDefault()</code> 里面，最终会默认初始化一个 Apache 的 Httpclient。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpClientConfig <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HttpClientConfig config = <span class="keyword">new</span> HttpClientConfig();</span><br><span class="line">    config.setClientType(HttpClientType.ApacheHttpClient);</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此为什么官方文档上写的 <code>System.setProperty</code> 不生效的原因终于找到了。也就是说，如果你是按照官方文档来写的代码，那么你通过 <code>System.setProperty</code> 来设置代理是肯定不是生效的。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol><li>将<code>HTTPS_PROXY</code> 或者 <code>HTTP_PROXY</code> 设置为系统环境变量（可以生效，但是不推荐）</li><li>在 <code>buildClient</code> 方法里面，可以发现只有当 <code>HttpClientConfig</code> 为空的情况下才会创建默认的 config，那么我们可以在 <code>IClientProfile</code> 里面，手动的将 <code>HttpClientConfig</code> 设置进去，从而避免创建默认的<code>HttpClientConfig</code>。<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/%E9%98%BF%E9%87%8CSDK%E7%9A%84%E5%9D%91/solve-plan.png" alt=""></li><li>用 JDK 的 <code>HttpURLConnection</code> 发请求，通过 <code>System.setProperty</code> 设置代理。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于项目中需要使用阿里云的短信平台，所以直接引用了最新的SDK，版本号为 &lt;code&gt;4.5.1&lt;/code&gt;。但是由于机器在内网环境，如果需要访问外部网络的话，需要代理机器。于是去看下 阿里的SDK 官方文档，如何支持代理访问，于是找到以下内容：&lt;/p&gt;
&lt;p&gt;&lt;img 
      
    
    </summary>
    
      <category term="阿里云" scheme="https://somersames.github.io/categories/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
    
      <category term="Java" scheme="https://somersames.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
