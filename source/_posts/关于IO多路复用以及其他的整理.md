---
title: 关于IO多路复用以及其他的整理
date: 2018-04-28 23:35:24
tags: [计算机基础]
categories: [计算机基础]
---

记得去年去年10月份的时候一个电话面试，当时面试官由多线程那一部分知识转到了IO部分，先提出同步IO和异步IO，最后面试官提出要一个IO的多路复用需要怎么去实现。但是由于对`多路复用` 的一些模式还是不太清楚，而现在正好在研究 `netty` 的时候想起来了，所以做一个总结算了。

## 同步IO
所谓的同步IO ，在刚学Java的Socket通信时就是一个阻塞IO，具体来讲就是在服务端的一个 while 中会调用 `Inputstream inputStream =scoket.getInputStream()` 在这里如果客户端没有发送数据的话，服务端就会一直卡在这里。或者说在接收数据的过程中会一直卡在这里，对于服务端来讲的话这里就是一个同步的，因为在这里没有接收到数据的话代码一直不能往下走。

## 异步阻塞IO Reactor IO多路复用

异步代表的是被调用方需要主动的反馈通知，就比如在本例中，读取Socket的流，如果在读取流的时候必须等待调用方自己去判断是否读取完毕，则这个就是一个同步IO。但是如果在调取的时候，每一次调用方都可以得到一个反馈，无论客户端是否准备就绪。则称之为异步的：如下：
```java
while(true){
InputStream in =read(); // 假设此时每次调用都会返回一个结果
Reader reader =new InputStreamReader(in);
}

```
此时就可以称之为一个异步IO，主要就是因为这个读取操作不再会被阻塞，每一次的调用，被调用方都会反馈一个信息.

在 Java 的  `Netty` 中每次循环都会去检查所有的key，看下是不是有的key可以都去了或者可以写入了之类的，这个就是一个典型的IO多路复用
 

## 同步非阻塞

继续以Socket举例：在同步IO的时候，没有收到数据是不会进行下一步操作的，但是同步非阻塞IO就是在这里直接判断数据准备好了没有，不管是否有数据，直接进行下一步操作。


## 异步非阻塞

异步IO指的是调用方不必在这里一直询问是否准备好数据没，而是直接执行代码，最后等待被调用方的一个通知即可。在这里还没有找到很好的举例


## 扩展
在这里其实在Java的多线程中 CallBack 和 Future 类似，当CallBack执行完毕之后再执行 Future 便可以得到一个结果，但是这个是一个同步阻塞的，异步